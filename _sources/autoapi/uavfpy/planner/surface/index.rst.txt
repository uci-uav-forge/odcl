:py:mod:`uavfpy.planner.surface`
================================

.. py:module:: uavfpy.planner.surface

.. autoapi-nested-parse::

   
   ..
       !! processed by numpydoc !!


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   uavfpy.planner.surface.generate_xy_grid
   uavfpy.planner.surface.generate_random_obstacles
   uavfpy.planner.surface.place_obstacles
   uavfpy.planner.surface.get_optimal_grid



.. py:function:: generate_xy_grid(xrange, yrange, step)

   
   Generate an x y grid over `xrange` `yrange` with grid-size `step`.


   :Parameters:

       **xrange** : tuple of float
           x_lower, x_upper

       **yrange** : tuple of float
           x_lower, x_upper

       **step** : float
           step size of the grid.

   :Returns:

       tuple of np.ndarray
           outputs are given as a tuple of (X, Y) grids, each corresponding
           to the X and Y values. The index of the grid corresponds to the
           relationship between points in the grid.













   ..
       !! processed by numpydoc !!

.. py:function:: generate_random_obstacles(n, xrange: Tuple[float, float], yrange: Tuple[float, float], radrange: Tuple[float, float], height_range: Tuple[float, float]) -> dict

   
   Generate list of `n` random obstacles within the x, y space.


   :Parameters:

       **n** : int
           no of obstacles to generate

       **xrange** : tuple of float
           upper and lower x coordinates of the obstacles

       **yrange** : tuple of float
           upper and lower y coordinates of the obstacles

       **radrange** : tuple of float
           upper and lower range of obstacle radius

       **height_range** : tuple of float
           upper and lower range of obstacle height

   :Returns:

       list of dict
           dict with keys "x", "y", "r", "h"













   ..
       !! processed by numpydoc !!

.. py:function:: place_obstacles(X, Y, obstacles)

   
   Make a new grid, with the same dimensions as `X`, `Y`, containing
   the obstacles contained in `obstacles.`

   The obstacles will overlap each other by the order they are given in
   the list. So if an O1 overlaps O2, but has a height less than O2, the
   portion that overlaps will be overwritten with O1's height.

   :Parameters:

       **X** : np.ndarray
           MxN array of x values.

       **Y** : np.ndarray
           MxN array of y values.

       **obstacles** : list of dict
           eahc obstacle is dict with fields "x", "y", "r", "h"

   :Returns:

       np.ndarray
           MxN array of H values corresponding to the "ground" as if obstacles
           have been placed there.













   ..
       !! processed by numpydoc !!

.. py:function:: get_optimal_grid(X, Y, H, buffer, max_dh, max_d2h, min_h, step: Tuple[float, float], waypoints=None, waypointcost=100000.0, verbose=True, solver='ECOS')

   
   Get an optimal height grid corresponding to a surface above the ground from an
   obstacle height grid `H`. The height grid has a minimum dh/dx, d2h/d2x, min h,
   and buffer between tall obstacles and the surface. The input grid `H` is structured
   like an MxN array of h values. The x, y positions are given by separate `X` and `Y`
   grids.


   :Parameters:

       **H** : np.ndarray
           height grid

       **buffer** : float
           minimum distance to obstacle or ground

       **max_dh** : float
           maximum dh/dx that the vehicle can climb. Corresponds to the "slope" of the
           sheet, or the max climb angle of the vehicle

       **max_d2h** : float
           maximum d2h/dx2 that the vehicle can accelerate to climb. smaller
           values correspond to a "smoother" sheet.

       **min_h** : float
           minimum altitude of the sheet `h`, irrespective of obstacles

       **step** : step
           grid step

       **verbose** : bool, optional
           whether to print verbose solver information, by default True

       **solver** : str, optional
           the solver to use. The solver must be accessible to `cvxpy`, by default "ECOS"

   :Returns:

       np.ndarray
           an array with the same dimensions as `H`, corresponding to the sheet above `H`.













   ..
       !! processed by numpydoc !!

