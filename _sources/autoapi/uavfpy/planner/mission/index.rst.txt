:py:mod:`uavfpy.planner.mission`
================================

.. py:module:: uavfpy.planner.mission

.. autoapi-nested-parse::

   
   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   uavfpy.planner.mission.Mission



Functions
~~~~~~~~~

.. autoapisummary::

   uavfpy.planner.mission.get_xformer_from_CRS_str



Attributes
~~~~~~~~~~

.. autoapisummary::

   uavfpy.planner.mission.CRS
   uavfpy.planner.mission.FT2METER
   uavfpy.planner.mission.METER2FT
   uavfpy.planner.mission.mission_json


.. py:data:: CRS
   

   
















   ..
       !! processed by numpydoc !!

.. py:data:: FT2METER
   :annotation: = 3.28084

   
















   ..
       !! processed by numpydoc !!

.. py:data:: METER2FT
   :annotation: = 0.3048

   
















   ..
       !! processed by numpydoc !!

.. py:function:: get_xformer_from_CRS_str(from_str: str, to_str: str)

   
   Get pyproj transformer from string. Example strings are:

   "Irvine" - Near Irvine area (feet)
   "Maryland" - Near Maryland area (feet)
   "WGS84" - WGS84 latitude/longitude coordinates

   :Parameters:

       **from_str** : str
           Key in `CRS` corresponding to a place

       **to_str** : str
           Key in `CRS` corresponding to a place

   :Returns:

       pyproj.Transformer
           the Pyproj transformer object.













   ..
       !! processed by numpydoc !!

.. py:class:: Mission(mission_json: str, wgs2loc: pyproj.Transformer, loc2wgs: pyproj.Transformer, grid_buffer: Tuple[float, float], grid_max_npoints: Tuple[int, int], grid_stepxy: Tuple[float, float])

   Bases: :py:obj:`object`

   
   Object representing a mission.


   :Parameters:

       **mission_json** : str
           Json string containing the mission. You can obtain this from the interop
           server.

       **wgs2loc** : pyproj.Transformer
           transform projection from WGS84 to local coordinate system

       **loc2wgs** : pyproj.Transformer
           transform projection from local coordinate system to WGS84

       **grid_buffer** : Tuple[float, float]
           the buffer to add around the outside boundaries of the misssion when
           creating the occupancygrid, in feet

       **grid_max_npoints** : Tuple[int, int]
           maximum number of points in the x,y direction to use when creating the
           occupancygrid. Set this to be the largest grid you want to process/plan
           over.

       **grid_stepxy** : Tuple[float, float]
           desired step size in the x,y direction when creating the occupancygrid. This
           step size is used only when the resulting grid size is under
           `grid_max_npoints` in the x or y direction.














   ..
       !! processed by numpydoc !!
   .. py:method:: get_occupancygrid(self, boundaries: numpy.ndarray, Hterrain: numpy.ndarray, alt_max: float) -> numpy.ndarray

      
      Get the occupancy grid for the mission. The occupancy grid is a grid where 0 is
      the allowable space and 1 is the forbidden space. The vehicle cannot fly outside
      of the mission bounds, or at any x,y location where the obstacle is higher than
      the maximum altitude. However, x,y positions where the obstacle is shorter than
      the maximum altitude can be flown by the vehicle. The surface planner will route
      the vehicle over those obstacles -- therefore, their x,y position is marked
      valid.


      :Parameters:

          **boundaries** : np.ndarray
              ordered boundary points

          **Hterrain** : np.ndarray
              Height of the "terrain." This is the array containing a static obstacle
              height for each space in x,y. z=0 where there is no static obstacle,
              z=obs_height where there is a static obstacle.

          **alt_max** : float
              max altitude for this region

      :Returns:

          np.ndarray
              MxN array of 0s and 1s, where 1 is the forbidden space and 0 is the allowed
              space. So, for an i,j grid point corresponding to some X[ij], Y[ij] pair, we
              can query the occupancygrid returned by this function to determine if the
              vehicle is allowed there.













      ..
          !! processed by numpydoc !!

   .. py:method:: cover_grid(self, poly: numpy.ndarray, buffer: Tuple[float, float], max_npoints: Tuple[int, int], stepxy: Tuple[float, float])

      
      get a grid of points which cover a polygon. Polygon is an ordered list of
      boundary points in the local coordinate system. buffer is the buffer around the
      polygon. max_npoints is the maximum points in both x and y direcitons. stepxy is
      the desired size of a grid cell in the x and y directions. this method will
      return a grid covering the polygon (plus the buffer) with either the desired
      step size or the maximum number of points, whichever is smaller.

      For example: if my polygon covers a region of 90m x 90m, and my grid buffer is
      (5m, 5m), the grid will be (100m x 100m). If I then specify a max number of
      points of (100 x 100), the grid (with the max number of points!) is a (100x100)
      grid with each cell being 1m x 1m. If I specify a step size of (5m x 5m),
      though, I will get a grid that is (20 x 20).

      It is recommended to create a grid with sufficient resolution to produce
      accurate paths (i.e., a grid with a cell size of 100m x 100m is useless if I
      want to plan paths to within 3m x 3m!). But not with resolution that is so large
      that computing paths will take a crazy amount of time to plan.

      :Parameters:

          **poly** : np.ndarray
              Polygon to cover, as (M x 2) ndarray in local coordinate system.

          **buffer** : Tuple[float, float]
              Buffer in x and y direction.

          **max_npoints** : Tuple[int, int]
              Max number of grid points to produce in (x,y) direction.

          **stepxy** : Tuple[float, float]
              Desired cell dimensions in x and y direction.

      :Returns:

          Tuple[np.ndarray, np.ndarray, tuple]
              X coordinates of the grid, Y coordinates of the grid, and a single cell's size.













      ..
          !! processed by numpydoc !!

   .. py:method:: get_nearest_grid_idx(self, x, y)

      
      Get index of the nearest grid point in (X, Y) to a point (x, y)


      :Parameters:

          **x** : float
              point x

          **y** : float
              point y

          **X** : np.ndarray
              array of grid points X

          **Y** : np.ndarray
              array of grid points Y














      ..
          !! processed by numpydoc !!

   .. py:method:: json_get_boundaries(self) -> Tuple[list, list, list]

      
      get mission boundaries. missions can, according to the schema, have multiple
      areas. Each of these areas would have a list of boundaries and a max/min height.



      :Returns:

          Tuple[list, list, list]
              mission boundaries. The first is a list-of-lists containing boundaries in
              local coordinates, the second is a list of max altitudes, and the third is a
              list of min altitudes.













      ..
          !! processed by numpydoc !!

   .. py:method:: json_get_search_boundaries(self) -> numpy.ndarray

      
      get search boundaries in local coordinates as ordered ndarray



      :Returns:

          np.ndarray
              search boundaries













      ..
          !! processed by numpydoc !!

   .. py:method:: json_get_ordered_waypoints(self) -> numpy.ndarray

      
      get the ordered waypoints in local coordinate frame as ndarray



      :Returns:

          np.ndarray
              ordered waypoints in local coordinate system













      ..
          !! processed by numpydoc !!

   .. py:method:: json_get_obstacles(self) -> list

      
      get obstacles from the mission json



      :Returns:

          list
              list of obstacles as list of dict with keys x, y, r, h













      ..
          !! processed by numpydoc !!

   .. py:method:: get_Hsurf(self) -> numpy.ndarray

      
      Get the optimal surface height for each grid point



      :Returns:

          np.ndarray
              The surface height for each grid point




      :Raises:

          ValueError
              If solve_Hsurf() has not been called









      ..
          !! processed by numpydoc !!

   .. py:method:: solve_Hsurf(self, buffer: float, max_dh: float, max_d2h: float, solve_shape: tuple = (100, 100), verbose: bool = True)

      
      Solve the surface given mission parameters. This method may take some time to
      run, and may fail to run if a convergent solution cannot be found. The method
      downsamples the terrain object to size `solve_shape`, solves a convex
      optimization problem over that downscaled terrain to produce the optimal
      surface, then upscales the surface to the original terrain (and hence, occupancy
      grid) size. small values of `solve_shape` will result in faster convergence, but
      may produce quantization artifacts.

      buffer, max_dh, and max_d2h are parameters of the optimization problem; in
      general, small values of max_dh and max_d2h will cause the surface to be
      "smoother" but may also result in an infeasible problem. In particular, if
      waypoints are at different altitudes, but placed very close to one another,
      max_dh and max_d2h must be set large enough to produce a feasible path between
      the two waypoints.

      It is recommended that you experiment with these parameters for your particular
      mission to avoid solver errors.

      This method calls the method `surface.get_optimal_grid()`.

      :Parameters:

          **buffer** : float
              vertical safety buffer between the solved sheet and the surface of objects.

          **max_dh** : float
              maximum dh/dxy allowed for the vehicle. A dh/dxy of 1 means that the vehicle
              can climb or descend at most 1 meter for every meter of horizontal distance
              travelled.

          **max_d2h** : float
              maximum d2h/dxy^2 allowed for the vehicle. Setting this smaller means that
              the vehicle can pitch up or down slower.

          **solve_shape** : tuple, optional
              shape of the grid over which the optimization problem is solved. Larger
              values for this grid will be more accurate, but will take longer and may
              introduce solver errors, by default (100, 100)

          **verbose** : bool, optional
              whether to print verbose solver information, by default True














      ..
          !! processed by numpydoc !!

   .. py:method:: compute_plan_thru_waypoints(self, waypoints: numpy.ndarray, n: int = 2500, r_rewire: float = -1.0, plot=False)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: transform_to_wgs84(self, array: numpy.ndarray) -> numpy.ndarray

      
      Method to transform an (Mx2) array to WGS84 coordinates. (M x 3) arrays can be passed in but only the first two columns are touched.


      :Parameters:

          **array** : np.ndarray
              (M x 2+) array of M points in local coordinate system

      :Returns:

          np.ndarray
              (M x 2) array of transformed points in WGS84 coordinates













      ..
          !! processed by numpydoc !!

   .. py:method:: transform_from_wgs84(self, array: numpy.ndarray) -> numpy.ndarray

      
      Method to transform an (Mx2) array from WGS84 coordinates to local coordinates. (M x 3) arrays can be passed in but only the first two columns are touched.


      :Parameters:

          **array** : np.ndarray
              (M x 2+) array of M points in WGS84 coordinates

      :Returns:

          np.ndarray
              (M x 2) array of M points in local coordinates













      ..
          !! processed by numpydoc !!


.. py:data:: mission_json
   

   
















   ..
       !! processed by numpydoc !!

