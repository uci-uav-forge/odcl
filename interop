# /usr/bin/python3

#######################
#### Interop Client ###
#######################

# This rosnode coordinates communication between nodes
# on the ROS network and the AUVSI interop server. It
# relies on the `uavf` python package.


import time
from google.protobuf import json_format
from auvsi_suas.client import client
import rospy, threading
from std_msgs.msg import Header
from geographic_msgs.msg import (
    GeoPoint,
)
from uavfros.msg import (
    Mission,
    FlyZone,
    FlyZoneArray,
    GeoPolygon,
    GeoCylinder,
    Waypoints,
    StationaryObstacles,
    Team,
    TeamsArray,
)
from uavfros.srv import MissionService

# AUVSI SERVER INFO
SERVER_IP = "127.0.0.1"
SERVER_PORT = "8000"
SERVER_URL = f"http://{SERVER_IP}:{SERVER_PORT}"
USERNAME = "testadmin"
PASSWORD = "testpass"
MISSION_ID = 1

# TOPICS
MISSION_SERVER_TOPIC = "mission"

ODLC_TOPIC = "odlc"
MAPS_TOPIC = "map"
TELEMETRY_TOPIC = "telemetry"
OTHER_TEAMS_TOPIC = "other_teams"

# MISSION DATA MEMORY
mission_data = None

# TEAM STATUSES
updated_teams = {}

# GET TEAMS PERIOD
GET_TEAM_FREQ = 1

class UAVFInteropClient(client.AsyncClient):
    """Our implementation of the interop client. This class inherits from the auvsi client defined here:

    https://github.com/auvsi-suas/interop/blob/master/client/auvsi_suas/client/client.py
    """

    def __init__(self):
        super().__init__(SERVER_URL, USERNAME, PASSWORD)

    def get_mission(self, mission_id):
        mission = super().get_mission(mission_id)
        mission_dict = json_format.MessageToDict(mission.result())
        return mission_dict
    
    def get_teams(self):
        teams = super().get_teams()
        return teams.result()



def pack_teams_to_msg(teams: list):
    teamsArray = TeamsArray()
    for teamStatus in teams:
        if (updated_teams.has_key(teamStatus.TeamID.id) and updated_teams.get(teamStatus.TeamID.id) < teamStatus.telemetry_id) or not updated_teams.has_key(teamStatus.TeamID.id):
            updated_teams[teamStatus.TeamID.id] = teamStatus.telemetry_id
            msg = Team()
            msg.team_username = teamStatus.TeamID.username
            msg.team_id = teamStatus.TeamID.id
            msg.in_air = teamStatus.in_air
            msg.latitude = teamStatus.telemetry.latitude
            msg.longitude = teamStatus.telemetry.longitude
            msg.altitude = teamStatus.telemetry.altitude
            msg.heading = teamStatus.telemetry.heading
            msg.telemetry_id = teamStatus.telemetry_id
            msg.telemetry_age_sec = teamStatus.telemetry_age_sec
            msg.telemetry_timestamp = teamStatus.telemetry_timestamp
            teamsArray.teams.append(msg)
    if len(teamsArray.teams) > 0:
        return teamsArray
    else:
        return None



def other_teams_publisher():
    teamPublisher = rospy.Publisher(OTHER_TEAMS_TOPIC,TeamsArray,queue_size=10)
    rate = rospy.Rate(GET_TEAM_FREQ)
    while True:
        rate.sleep()
        teamsArray = pack_teams_to_msg(interopclient.get_teams())
        if teamsArray:
            teamPublisher.publish(teamsArray)        


def pack_mission_to_msg(mission: dict):
    msg = Mission()

    # header
    header = Header()
    header.stamp = rospy.get_rostime()
    # header.frame_id =
    msg.header = header

    # id
    msg.id = mission["id"]

    # lostCommsPos
    lostCommsPos = GeoPoint()
    lostCommsPos.latitude = mission["lostCommsPos"]["latitude"]
    lostCommsPos.longitude = mission["lostCommsPos"]["longitude"]
    msg.lostCommsPos = lostCommsPos

    # flyzones
    flyzones = []
    for zone in mission["flyZones"]:
        flyzone = FlyZone()
        flyzone.max_alt = zone["altitudeMax"]
        flyzone.min_alt = zone["altitudeMin"]
        boundaryPoints = []
        for points in zone["boundaryPoints"]:
            boundaryPoint = GeoPoint()
            boundaryPoint.latitude = points["latitude"]
            boundaryPoint.longitude = points["longitude"]
            boundaryPoints.append(boundaryPoint)
        flyzone.zone.points = boundaryPoints
        flyzones.append(flyzone)
    msg.flyzones.flyzones = flyzones

    # waypoints
    waypoints = []
    for waypoint in mission["waypoints"]:
        temp = GeoPoint()
        temp.latitude = waypoint["latitude"]
        temp.longitude = waypoint["longitude"]
        temp.altitude = waypoint["altitude"]
        waypoints.append(temp)
    msg.waypoints.waypoints = waypoints

    # searchGridPoints
    searchGridPoints = []
    for point in mission["searchGridPoints"]:
        temp = GeoPoint()
        temp.latitude = point["latitude"]
        temp.longitude = point["longitude"]
        searchGridPoints.append(temp)
    msg.searchGridPoints.points = searchGridPoints

    # offAxisOdlcPos
    msg.offAxisOdlcPos.latitude = mission["offAxisOdlcPos"]["latitude"]
    msg.offAxisOdlcPos.longitude = mission["offAxisOdlcPos"]["longitude"]

    # emergentLastKnownPos
    msg.emergentLastKnownPos.latitude = mission["emergentLastKnownPos"]["latitude"]
    msg.emergentLastKnownPos.longitude = mission["emergentLastKnownPos"]["longitude"]

    # airDropBoundaryPoints
    boundaryPoints = []
    for point in mission["airDropBoundaryPoints"]:
        temp = GeoPoint()
        temp.latitude = point["latitude"]
        temp.longitude = point["longitude"]
        boundaryPoints.append(temp)
    msg.airDropBoundaryPoints.points = boundaryPoints

    # airDropPos
    msg.airDropPos.latitude = mission["airDropPos"]["latitude"]
    msg.airDropPos.longitude = mission["airDropPos"]["longitude"]

    # ugvDropPos
    msg.ugvDrivePos.latitude = mission["ugvDrivePos"]["latitude"]
    msg.ugvDrivePos.longitude = mission["ugvDrivePos"]["longitude"]

    # stationaryObstacles
    stationaryObstacles = []
    for obstacle in mission["stationaryObstacles"]:
        temp = GeoCylinder()
        temp.center.latitude = obstacle["latitude"]
        temp.center.longitude = obstacle["longitude"]
        temp.height = obstacle["height"]
        temp.radius = obstacle["radius"]
        stationaryObstacles.append(temp)
    msg.stationaryObstacles.stationaryObstacles = stationaryObstacles

    # mapCenterPos
    msg.mapCenterPos.latitude = mission["mapCenterPos"]["latitude"]
    msg.mapCenterPos.longitude = mission["mapCenterPos"]["longitude"]

    # mapHeight
    msg.mapHeight = mission["mapHeight"]

    return msg


def handle_mission(req):
    mission_data = interopclient.get_mission(MISSION_ID)
    return pack_mission_to_msg(mission_data)


def mission_server():
    mission_serv = rospy.Service(MISSION_SERVER_TOPIC, MissionService, handle_mission)
    rospy.spin()


# def odlc_callback(data):
#     client.upload_odlc(data)


# def maps_callback(data):
#     client.upload_map(1, data)


# def telemetry_callback(data):
#     client.upload_telemetry(data)


# def listener():
#     rospy.Subscriber(ODLC_TOPIC, Odlc, odlc_callback)
#     rospy.Subscriber(MAPS_TOPIC, Map, maps_callback)
#     rospy.Subscriber(TELEMETRY_TOPIC, Telemetry, telemetry_callback)
#     rospy.spin()


def main():
    rospy.init_node("interop_client", anonymous=True)

    global interopclient
    interopclient = UAVFInteropClient()

    # listenerThread = threading.Thread(target=listener)
    # listenerThread.setDaemon(True)
    # listenerThread.start()

    # other_teams_publisher()

    mission_server()


if __name__ == "__main__":
    main()
