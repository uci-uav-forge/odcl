<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>path_planning.boustrophedon_decomposition API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>path_planning.boustrophedon_decomposition</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from tkinter import *
from math import *


# CODE IS DEPENDENT ON WHICH &#34;DIRECTION&#34; COORDINATES ARE ENTERED IN BOUNDARY COORDINATE TEST VARIABLE
# CROSS PRODUCT IS USED TO DETERMINE CONVEX VS CONCAVE VERTICES, THIS WILL BE POSITIVE OR NEGATIVE DEPENDING
# ON THE ORDER THE COORDINATES ARE INPUTTED IN THE LIST &#34;BOUNDARY_COORDINATES&#34;
# code was tested inputting points clockwise


class Line:
    &#39;&#39;&#39;
    straight line created by connecting [x1,y1] and [x2,y2]
    tkinter returns a unique identifier when create_line is called
    identifier can be used to delete the line later with canvas.delete(...)

    Parameters:
    x1: float
    y1: float
    x2: float
    y2: float
    identifier: int

    Returns:
    none
    &#39;&#39;&#39;

    def __init__(self, x1, y1, x2, y2, identifier=0):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.identifier = identifier

    def slope(self):
        &#39;&#39;&#39;
        uses rise/run formula to calculate slope
        returns string &#34;undefined&#34; and prints an error if the line is vertical

        Parameters:
        none

        Returns:
        none
        &#39;&#39;&#39;
        try:
            return (self.y2 - self.y1) / (self.x2 - self.x1)
        except ZeroDivisionError:
            #print(&#34;Divide by zero error&#34;)
            return &#34;undefined&#34;

    def intercept(self):
        &#39;&#39;&#39;
        uses y=mx+b -&gt; b=y-mx to calculate y-intercept
        returns string &#34;does not exist&#34; and prints an error if the line is vertical
        &#39;&#39;&#39;
        try:
            return self.y2 - self.slope() * self.x2
        except TypeError:
            print(&#34;Y-intercept does not exist due to undefined slope&#34;)
            return &#34;does not exist&#34;


def intersects(l1, l2):
    &#39;&#39;&#39;
    Tests if two line segments intersect
    Also returns true if line segments touch but do not pass through

    Parameters:
    l1: Line object
    l2: Line object

    Returns:
    True if line segments intersect or touch each other
    False if line segments do not touch each other
    &#39;&#39;&#39;
    # check if domains share values
    if max(min(l1.x1, l1.x2), min(l2.x1, l2.x2)) &gt; min(max(l1.x1, l1.x2), max(l2.x1, l2.x2)):
        return False

    # check if ranges share values
    if max(min(l1.y1, l1.y2), min(l2.y1, l2.y2)) &gt; min(max(l1.y1, l1.y2), max(l2.y1, l2.y2)):
        return False

    # if slopes are equal, check if collinear
    # accounts for collinear vertical lines: l1.slope() == l2.slope() == &#34;undefined&#34;
    if l1.slope() == l2.slope():
        if l1.intercept() == l2.intercept():
            return True
        else:
            return False

    # calculate x-coordinate of intersection point, if l1 or l2 is vertical, sets x-coordinate as x-intersection
    if l1.slope() == &#34;undefined&#34; or l2.slope() == &#34;undefined&#34;:
        if l1.slope() == &#34;undefined&#34; and min(l1.y1,l1.y2)&lt;l2.slope()*l1.x1+l2.intercept()&lt;max(l1.y1,l1.y2):
            x_intersection = l1.x1
        elif l2.slope() == &#34;undefined&#34; and min(l2.y1,l2.y2)&lt;l1.slope()*l2.x1+l1.intercept()&lt;max(l2.y1,l2.y2):
            x_intersection = l2.x1
        else:
            return False
    else:

        # round due to floating point arithmetic yielding incorrect results when the end of one line is equal to the
        # start of another line
        x_intersection = round((l2.intercept() - l1.intercept()) / (l1.slope() - l2.slope()), 5)

    # if x_intersection is within shared domain, return true
    if x_intersection &lt; max(min(l1.x1, l1.x2), min(l2.x1, l2.x2)) or x_intersection &gt; min(max(l1.x1, l1.x2), max(l2.x1, l2.x2)):
        return False
    else:
        return True


def init_gui(w, h):
    &#39;&#39;&#39;
    Initializes a canvas with specified width and height

    Parameters:
    w: int
        width in pixels of the canvas
    h: int
        height in pixels of the canvas

    Returns:
    canv: Canvas object
        canvas window with specified width and height
    &#39;&#39;&#39;
    master = Tk()
    canv = Canvas(master, width=w, height=h, bg=&#39;#fff&#39;)
    canv.pack()
    return canv


def start_gui():
    &#39;&#39;&#39;
    Opens a canvas window

    Parameters:
    none

    Returns:
    none
    &#39;&#39;&#39;
    mainloop()


def draw_boundary(canv, coordinates):
    &#34;&#34;&#34;
    Draws the outer boundary of the zone to be covered
    Writes coordinates in [x,y] on every point in the boundary

    Parameters:
    canv: Canvas object
        canvas on which to draw boundary lines
    coordinates: list of [int,int]
        list of coordinate pairs making up the boundary

    Returns:
    none
    &#34;&#34;&#34;
    boundary = coordinates_to_lines(coordinates)
    for line in boundary:
        canv.create_text(line.x1, line.y1, text=&#34;[&#34; + str(line.x1) + &#39;,&#39; + str(line.y1) + &#34;]&#34;)
        canv.create_line(line.x1, line.y1, line.x2, line.y2)


def coordinates_to_lines(coordinates):
    &#39;&#39;&#39;
    Takes a list of coordinates and returns a list of lines connecting the points in sequence
    In addition, connects the first point to the last point

    Parameters:
    coordinates: list of [int, int]
        list of coordinates to convert to lines [[x1,y1], [x2,y2], ... , [xn,yn]]

    Returns:
    lines: list of Line
        list of lines created by connecting coordinate points in order
    &#39;&#39;&#39;
    lines = []
    for index, coordinate in enumerate(coordinates):
        lines.append(Line(coordinates[index - 1][0], coordinates[index - 1][1], coordinates[index][0], coordinates[index][1]))
    return lines


# should change so that this function can create lines tangent to circles, not just lines intersecting with points
def boustrophedon_line_sweep(canv, angle, lines, orig_points, concave=False):
    &#39;&#39;&#39;
    Performs a boustrophedon decomposition with a line sweep perpendicular to the angle specified in the function call
    Draws lines that satisfy the requirements of boustrophedon decomposition
    Currently must be run on the boundary and every obstacle individually (improvements can be made here)
    Concave parameter indicates whether to keep lines that occur at concave vertices or convex vertices

    Parameters:
    canv: Canvas object
        canvas window on which to perform the line sweep
    angle: Float
        angle in degrees counterclockwise from +x-axis
    orig_points: list of [int, int]
        list of coordinates making up the boundary or the obstacle
    concave: boolean
        True if performing this function on a boundary
        False if performing this function on an obstacle

    Returns:
    none
    &#39;&#39;&#39;
    slope = -tan(angle * pi / 180)
    points = orig_points[:]
    points.append(points[0])
    if concave:
        indices = extract_concave_vertices(orig_points)
    else:
        indices = extract_convex_vertices(orig_points)
    if slope == 0:
        for num in indices:
            y1 = points[num][1]
            y2 = points[num][1]
            x1 = 0
            x2 = canvas_width
            if check_line_inside_boundary(points[num - 1], points[num], points[num + 1], x1, y1):
                canv.create_line(x1, y1, x2, y2)
    else:
        # for every index of a vertex that was concave (boundary) or convex (obstacle)
        # check whether to draw a line originating from that point
        for num in indices:
            y1 = 0
            y2 = canvas_height
            x1 = (0 - points[num][1] + slope * points[num][0]) / slope
            x2 = (y2 - points[num][1] + slope * points[num][0]) / slope

            # if index of that vertex is 0, manually assign points to check against
            # if index of that vertex is not 0, use the vertex before and after it in the list of coordinates
            # to see whether the line created will lie inside the bounds of the region
            if (num != 0 and check_line_inside_boundary(points[num - 1], points[num], points[num + 1], x1, y1)) or (num == 0 and check_line_inside_boundary(points[len(points)-2],points[0], points[1], x1, y1)):
                long_line = Line(x1, y1, x2, y2)
                x_intercepts = []
                for l in lines:
                    if intersects(long_line, l):
                        if long_line.slope() == &#34;undefined&#34; or l.slope() == &#34;undefined&#34;:
                            if long_line.slope() == &#34;undefined&#34;:
                                x_intersection = long_line.x1
                            if l.slope() == &#34;undefined&#34;:
                                x_intersection = l.x1
                        else:
                            x_intersection = round((l.intercept() - long_line.intercept()) / (long_line.slope() - l.slope()), 5)
                        if x_intersection != points[num][0]:
                            # if the decomposition line being drawn is collinear with a boundary line, do not include
                            # any x-coordinates that are contained within that boundary line in the list of
                            # x-coordinates of intersections
                            # if index is 0, manually check intersection
                            if num == 0:
                                if (x_intersection != points[len(points)-2][0] and x_intersection != points[1][0]):
                                    x_intercepts.append(x_intersection)
                            elif x_intersection != points[num-1][0] and x_intersection != points[num+1][0]:
                                x_intercepts.append(x_intersection)

                # set the proper x-bounds for the decomposition line so that it originates from the specified vertex
                # and stops when it hits another line
                x_lower = min(x1, x2)
                x_upper = max(x1, x2)
                for x_int in x_intercepts:
                    if x_int &lt; points[num][0]:
                        if x_int &gt; x_lower:
                            x_lower = x_int
                    if x_int &gt; points[num][0]:
                        if x_int &lt; x_upper:
                            x_upper = x_int
                y1 = slope*(x_lower-points[num][0])+points[num][1]
                y2 = slope*(x_upper-points[num][0])+points[num][1]
                canv.create_line(x_lower, y1, x_upper, y2)


def cross_product(p1, p2, p3):
    &#39;&#39;&#39;
    Takes the cross product between vectors &lt;v21&gt; and &lt;v23&gt;

    Parameters:
    p1: list of int, len(list)=2
        first set of coordinates [x1,y1]
    p1: list of int, len(list)=2
        second set of coordinates [x2,y2]
    p1: list of int, len(list)=2
        third set of coordinates [x3,y3]

    Returns:
    int
        computed cross product
        most use cases within this file look at sign of cross-product, not necessarily the numerical value
    &#39;&#39;&#39;
    dx1 = p1[0] - p2[0]
    dy1 = p1[1] - p2[1]
    dx2 = p3[0] - p2[0]
    dy2 = p3[1] - p2[1]
    return dx1 * dy2 - dy1 * dx2


def extract_concave_vertices(orig_coordinates):
    &#39;&#39;&#39;
    Takes a list of coordinates, assumes they connect in the sequence they are listed to form a polygon, and returns
    the indices of coordinates that are concave vertices of that polygon

    Parameters:
    orig_coordinates: list of [int, int]
        list of coordinates making up the polygon

    Returns:
    list of int
        list containing the index of every coordinate that is a concave vertex
    &#39;&#39;&#39;
    convex_vertices = []
    coordinates = orig_coordinates[:]
    if cross_product(coordinates[-1], coordinates[0], coordinates[1]) &gt; 0:
        convex_vertices.append(0)
    coordinates.append(coordinates[0])
    for index, point in enumerate(coordinates):
        if cross_product(coordinates[index-2], coordinates[index-1], coordinates[index]) &gt; 0:
            convex_vertices.append(index-1)
    return convex_vertices


def extract_convex_vertices(orig_coordinates):
    &#39;&#39;&#39;
    Takes a list of coordinates, assumes they connect in the sequence they are listed to form a polygon, and returns
    the indices of coordinates that are convex vertices of that polygon

    Parameters:
    orig_coordinates: list of [int, int]
        list of coordinates making up the polygon

    Returns:
    list of int
        list containing the index of every coordinate that is a convex vertex
    &#39;&#39;&#39;
    concave_vertices = []
    coordinates = orig_coordinates[:]
    if cross_product(coordinates[-1], coordinates[0], coordinates[1]) &lt; 0:
        concave_vertices.append(0)
    coordinates.append(coordinates[0])
    for index, point in enumerate(coordinates):
        if cross_product(coordinates[index-2], coordinates[index-1], coordinates[index]) &lt; 0:
            concave_vertices.append(index-1)
    return concave_vertices


def check_line_inside_boundary(p1, p2, p3, x1, y1):
    &#39;&#39;&#39;
    Uses cross product to check if a line is locally contained within the boundary or rests on the outside of an obstacle
    Checks if line passes between &lt;v21&gt; and &lt;v23&gt; or if it passes &#39;tangent&#39; to p2

    Parameters:
    p1: list of int, len(list)=2
        first set of coordinates [x1,y1]
    p1: list of int, len(list)=2
        second set of coordinates [x2,y2]
    p1: list of int, len(list)=2
        third set of coordinates [x3,y3]
    x1: int
        select any point on the line [x1,y1] OTHER than [p2[0],p2[1]]
    y1: int
        select any point on the line [x1,y1] OTHER than [p2[0],p2[1]]

    Returns:
    boolean
        True if one cross-product is positive and one is negative
        False if both cross-products have the same sign
    &#39;&#39;&#39;
    if (cross_product(p1, p2, [x1, y1]) &gt; 0) ^ (cross_product([x1, y1], p2, p3) &gt; 0):
        return True
    else:
        return False


############################
# INITIALIZE TEST CONDITIONS
############################
boundary_coordinates = [[150, 280], [200, 200], [450, 260], [470, 220], [400, 100], [585, 82.5], [770, 65], [830, 300],
                        [760, 500], [520, 520], [450, 440], [350, 400], [210, 420]]
test_obstacle_coordinates = [[600, 200], [675, 275], [600, 350], [525, 275]]
test_obstacle_coordinates_2 = [[650, 120], [700, 120], [700, 170], [650, 170]]
all_lines = []
for line in coordinates_to_lines(boundary_coordinates) + coordinates_to_lines(test_obstacle_coordinates) + coordinates_to_lines(test_obstacle_coordinates_2):
    all_lines.append(line)

# theta can be any number != 0, 90
theta = -25
canvas_width = 1280
canvas_height = 720


canvas = init_gui(canvas_width, canvas_height)
draw_boundary(canvas, boundary_coordinates)
draw_boundary(canvas, test_obstacle_coordinates)
draw_boundary(canvas, test_obstacle_coordinates_2)
boustrophedon_line_sweep(canvas, theta, all_lines, boundary_coordinates, concave=True)
boustrophedon_line_sweep(canvas, theta, all_lines, test_obstacle_coordinates, concave=False)
boustrophedon_line_sweep(canvas, theta, all_lines, test_obstacle_coordinates_2, concave=False)
start_gui()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="path_planning.boustrophedon_decomposition.boustrophedon_line_sweep"><code class="name flex">
<span>def <span class="ident">boustrophedon_line_sweep</span></span>(<span>canv, angle, lines, orig_points, concave=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a boustrophedon decomposition with a line sweep perpendicular to the angle specified in the function call
Draws lines that satisfy the requirements of boustrophedon decomposition
Currently must be run on the boundary and every obstacle individually (improvements can be made here)
Concave parameter indicates whether to keep lines that occur at concave vertices or convex vertices</p>
<p>Parameters:
canv: Canvas object
canvas window on which to perform the line sweep
angle: Float
angle in degrees counterclockwise from +x-axis
orig_points: list of [int, int]
list of coordinates making up the boundary or the obstacle
concave: boolean
True if performing this function on a boundary
False if performing this function on an obstacle</p>
<p>Returns:
none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boustrophedon_line_sweep(canv, angle, lines, orig_points, concave=False):
    &#39;&#39;&#39;
    Performs a boustrophedon decomposition with a line sweep perpendicular to the angle specified in the function call
    Draws lines that satisfy the requirements of boustrophedon decomposition
    Currently must be run on the boundary and every obstacle individually (improvements can be made here)
    Concave parameter indicates whether to keep lines that occur at concave vertices or convex vertices

    Parameters:
    canv: Canvas object
        canvas window on which to perform the line sweep
    angle: Float
        angle in degrees counterclockwise from +x-axis
    orig_points: list of [int, int]
        list of coordinates making up the boundary or the obstacle
    concave: boolean
        True if performing this function on a boundary
        False if performing this function on an obstacle

    Returns:
    none
    &#39;&#39;&#39;
    slope = -tan(angle * pi / 180)
    points = orig_points[:]
    points.append(points[0])
    if concave:
        indices = extract_concave_vertices(orig_points)
    else:
        indices = extract_convex_vertices(orig_points)
    if slope == 0:
        for num in indices:
            y1 = points[num][1]
            y2 = points[num][1]
            x1 = 0
            x2 = canvas_width
            if check_line_inside_boundary(points[num - 1], points[num], points[num + 1], x1, y1):
                canv.create_line(x1, y1, x2, y2)
    else:
        # for every index of a vertex that was concave (boundary) or convex (obstacle)
        # check whether to draw a line originating from that point
        for num in indices:
            y1 = 0
            y2 = canvas_height
            x1 = (0 - points[num][1] + slope * points[num][0]) / slope
            x2 = (y2 - points[num][1] + slope * points[num][0]) / slope

            # if index of that vertex is 0, manually assign points to check against
            # if index of that vertex is not 0, use the vertex before and after it in the list of coordinates
            # to see whether the line created will lie inside the bounds of the region
            if (num != 0 and check_line_inside_boundary(points[num - 1], points[num], points[num + 1], x1, y1)) or (num == 0 and check_line_inside_boundary(points[len(points)-2],points[0], points[1], x1, y1)):
                long_line = Line(x1, y1, x2, y2)
                x_intercepts = []
                for l in lines:
                    if intersects(long_line, l):
                        if long_line.slope() == &#34;undefined&#34; or l.slope() == &#34;undefined&#34;:
                            if long_line.slope() == &#34;undefined&#34;:
                                x_intersection = long_line.x1
                            if l.slope() == &#34;undefined&#34;:
                                x_intersection = l.x1
                        else:
                            x_intersection = round((l.intercept() - long_line.intercept()) / (long_line.slope() - l.slope()), 5)
                        if x_intersection != points[num][0]:
                            # if the decomposition line being drawn is collinear with a boundary line, do not include
                            # any x-coordinates that are contained within that boundary line in the list of
                            # x-coordinates of intersections
                            # if index is 0, manually check intersection
                            if num == 0:
                                if (x_intersection != points[len(points)-2][0] and x_intersection != points[1][0]):
                                    x_intercepts.append(x_intersection)
                            elif x_intersection != points[num-1][0] and x_intersection != points[num+1][0]:
                                x_intercepts.append(x_intersection)

                # set the proper x-bounds for the decomposition line so that it originates from the specified vertex
                # and stops when it hits another line
                x_lower = min(x1, x2)
                x_upper = max(x1, x2)
                for x_int in x_intercepts:
                    if x_int &lt; points[num][0]:
                        if x_int &gt; x_lower:
                            x_lower = x_int
                    if x_int &gt; points[num][0]:
                        if x_int &lt; x_upper:
                            x_upper = x_int
                y1 = slope*(x_lower-points[num][0])+points[num][1]
                y2 = slope*(x_upper-points[num][0])+points[num][1]
                canv.create_line(x_lower, y1, x_upper, y2)</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.check_line_inside_boundary"><code class="name flex">
<span>def <span class="ident">check_line_inside_boundary</span></span>(<span>p1, p2, p3, x1, y1)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses cross product to check if a line is locally contained within the boundary or rests on the outside of an obstacle
Checks if line passes between <v21> and <v23> or if it passes 'tangent' to p2</p>
<p>Parameters:
p1: list of int, len(list)=2
first set of coordinates [x1,y1]
p1: list of int, len(list)=2
second set of coordinates [x2,y2]
p1: list of int, len(list)=2
third set of coordinates [x3,y3]
x1: int
select any point on the line [x1,y1] OTHER than [p2[0],p2[1]]
y1: int
select any point on the line [x1,y1] OTHER than [p2[0],p2[1]]</p>
<p>Returns:
boolean
True if one cross-product is positive and one is negative
False if both cross-products have the same sign</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_line_inside_boundary(p1, p2, p3, x1, y1):
    &#39;&#39;&#39;
    Uses cross product to check if a line is locally contained within the boundary or rests on the outside of an obstacle
    Checks if line passes between &lt;v21&gt; and &lt;v23&gt; or if it passes &#39;tangent&#39; to p2

    Parameters:
    p1: list of int, len(list)=2
        first set of coordinates [x1,y1]
    p1: list of int, len(list)=2
        second set of coordinates [x2,y2]
    p1: list of int, len(list)=2
        third set of coordinates [x3,y3]
    x1: int
        select any point on the line [x1,y1] OTHER than [p2[0],p2[1]]
    y1: int
        select any point on the line [x1,y1] OTHER than [p2[0],p2[1]]

    Returns:
    boolean
        True if one cross-product is positive and one is negative
        False if both cross-products have the same sign
    &#39;&#39;&#39;
    if (cross_product(p1, p2, [x1, y1]) &gt; 0) ^ (cross_product([x1, y1], p2, p3) &gt; 0):
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.coordinates_to_lines"><code class="name flex">
<span>def <span class="ident">coordinates_to_lines</span></span>(<span>coordinates)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a list of coordinates and returns a list of lines connecting the points in sequence
In addition, connects the first point to the last point</p>
<p>Parameters:
coordinates: list of [int, int]
list of coordinates to convert to lines [[x1,y1], [x2,y2], &hellip; , [xn,yn]]</p>
<p>Returns:
lines: list of Line
list of lines created by connecting coordinate points in order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinates_to_lines(coordinates):
    &#39;&#39;&#39;
    Takes a list of coordinates and returns a list of lines connecting the points in sequence
    In addition, connects the first point to the last point

    Parameters:
    coordinates: list of [int, int]
        list of coordinates to convert to lines [[x1,y1], [x2,y2], ... , [xn,yn]]

    Returns:
    lines: list of Line
        list of lines created by connecting coordinate points in order
    &#39;&#39;&#39;
    lines = []
    for index, coordinate in enumerate(coordinates):
        lines.append(Line(coordinates[index - 1][0], coordinates[index - 1][1], coordinates[index][0], coordinates[index][1]))
    return lines</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.cross_product"><code class="name flex">
<span>def <span class="ident">cross_product</span></span>(<span>p1, p2, p3)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the cross product between vectors <v21> and <v23></p>
<p>Parameters:
p1: list of int, len(list)=2
first set of coordinates [x1,y1]
p1: list of int, len(list)=2
second set of coordinates [x2,y2]
p1: list of int, len(list)=2
third set of coordinates [x3,y3]</p>
<p>Returns:
int
computed cross product
most use cases within this file look at sign of cross-product, not necessarily the numerical value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross_product(p1, p2, p3):
    &#39;&#39;&#39;
    Takes the cross product between vectors &lt;v21&gt; and &lt;v23&gt;

    Parameters:
    p1: list of int, len(list)=2
        first set of coordinates [x1,y1]
    p1: list of int, len(list)=2
        second set of coordinates [x2,y2]
    p1: list of int, len(list)=2
        third set of coordinates [x3,y3]

    Returns:
    int
        computed cross product
        most use cases within this file look at sign of cross-product, not necessarily the numerical value
    &#39;&#39;&#39;
    dx1 = p1[0] - p2[0]
    dy1 = p1[1] - p2[1]
    dx2 = p3[0] - p2[0]
    dy2 = p3[1] - p2[1]
    return dx1 * dy2 - dy1 * dx2</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.draw_boundary"><code class="name flex">
<span>def <span class="ident">draw_boundary</span></span>(<span>canv, coordinates)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the outer boundary of the zone to be covered
Writes coordinates in [x,y] on every point in the boundary</p>
<p>Parameters:
canv: Canvas object
canvas on which to draw boundary lines
coordinates: list of [int,int]
list of coordinate pairs making up the boundary</p>
<p>Returns:
none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_boundary(canv, coordinates):
    &#34;&#34;&#34;
    Draws the outer boundary of the zone to be covered
    Writes coordinates in [x,y] on every point in the boundary

    Parameters:
    canv: Canvas object
        canvas on which to draw boundary lines
    coordinates: list of [int,int]
        list of coordinate pairs making up the boundary

    Returns:
    none
    &#34;&#34;&#34;
    boundary = coordinates_to_lines(coordinates)
    for line in boundary:
        canv.create_text(line.x1, line.y1, text=&#34;[&#34; + str(line.x1) + &#39;,&#39; + str(line.y1) + &#34;]&#34;)
        canv.create_line(line.x1, line.y1, line.x2, line.y2)</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.extract_concave_vertices"><code class="name flex">
<span>def <span class="ident">extract_concave_vertices</span></span>(<span>orig_coordinates)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a list of coordinates, assumes they connect in the sequence they are listed to form a polygon, and returns
the indices of coordinates that are concave vertices of that polygon</p>
<p>Parameters:
orig_coordinates: list of [int, int]
list of coordinates making up the polygon</p>
<p>Returns:
list of int
list containing the index of every coordinate that is a concave vertex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_concave_vertices(orig_coordinates):
    &#39;&#39;&#39;
    Takes a list of coordinates, assumes they connect in the sequence they are listed to form a polygon, and returns
    the indices of coordinates that are concave vertices of that polygon

    Parameters:
    orig_coordinates: list of [int, int]
        list of coordinates making up the polygon

    Returns:
    list of int
        list containing the index of every coordinate that is a concave vertex
    &#39;&#39;&#39;
    convex_vertices = []
    coordinates = orig_coordinates[:]
    if cross_product(coordinates[-1], coordinates[0], coordinates[1]) &gt; 0:
        convex_vertices.append(0)
    coordinates.append(coordinates[0])
    for index, point in enumerate(coordinates):
        if cross_product(coordinates[index-2], coordinates[index-1], coordinates[index]) &gt; 0:
            convex_vertices.append(index-1)
    return convex_vertices</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.extract_convex_vertices"><code class="name flex">
<span>def <span class="ident">extract_convex_vertices</span></span>(<span>orig_coordinates)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a list of coordinates, assumes they connect in the sequence they are listed to form a polygon, and returns
the indices of coordinates that are convex vertices of that polygon</p>
<p>Parameters:
orig_coordinates: list of [int, int]
list of coordinates making up the polygon</p>
<p>Returns:
list of int
list containing the index of every coordinate that is a convex vertex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_convex_vertices(orig_coordinates):
    &#39;&#39;&#39;
    Takes a list of coordinates, assumes they connect in the sequence they are listed to form a polygon, and returns
    the indices of coordinates that are convex vertices of that polygon

    Parameters:
    orig_coordinates: list of [int, int]
        list of coordinates making up the polygon

    Returns:
    list of int
        list containing the index of every coordinate that is a convex vertex
    &#39;&#39;&#39;
    concave_vertices = []
    coordinates = orig_coordinates[:]
    if cross_product(coordinates[-1], coordinates[0], coordinates[1]) &lt; 0:
        concave_vertices.append(0)
    coordinates.append(coordinates[0])
    for index, point in enumerate(coordinates):
        if cross_product(coordinates[index-2], coordinates[index-1], coordinates[index]) &lt; 0:
            concave_vertices.append(index-1)
    return concave_vertices</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.init_gui"><code class="name flex">
<span>def <span class="ident">init_gui</span></span>(<span>w, h)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a canvas with specified width and height</p>
<p>Parameters:
w: int
width in pixels of the canvas
h: int
height in pixels of the canvas</p>
<p>Returns:
canv: Canvas object
canvas window with specified width and height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_gui(w, h):
    &#39;&#39;&#39;
    Initializes a canvas with specified width and height

    Parameters:
    w: int
        width in pixels of the canvas
    h: int
        height in pixels of the canvas

    Returns:
    canv: Canvas object
        canvas window with specified width and height
    &#39;&#39;&#39;
    master = Tk()
    canv = Canvas(master, width=w, height=h, bg=&#39;#fff&#39;)
    canv.pack()
    return canv</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.intersects"><code class="name flex">
<span>def <span class="ident">intersects</span></span>(<span>l1, l2)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if two line segments intersect
Also returns true if line segments touch but do not pass through</p>
<p>Parameters:
l1: Line object
l2: Line object</p>
<p>Returns:
True if line segments intersect or touch each other
False if line segments do not touch each other</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersects(l1, l2):
    &#39;&#39;&#39;
    Tests if two line segments intersect
    Also returns true if line segments touch but do not pass through

    Parameters:
    l1: Line object
    l2: Line object

    Returns:
    True if line segments intersect or touch each other
    False if line segments do not touch each other
    &#39;&#39;&#39;
    # check if domains share values
    if max(min(l1.x1, l1.x2), min(l2.x1, l2.x2)) &gt; min(max(l1.x1, l1.x2), max(l2.x1, l2.x2)):
        return False

    # check if ranges share values
    if max(min(l1.y1, l1.y2), min(l2.y1, l2.y2)) &gt; min(max(l1.y1, l1.y2), max(l2.y1, l2.y2)):
        return False

    # if slopes are equal, check if collinear
    # accounts for collinear vertical lines: l1.slope() == l2.slope() == &#34;undefined&#34;
    if l1.slope() == l2.slope():
        if l1.intercept() == l2.intercept():
            return True
        else:
            return False

    # calculate x-coordinate of intersection point, if l1 or l2 is vertical, sets x-coordinate as x-intersection
    if l1.slope() == &#34;undefined&#34; or l2.slope() == &#34;undefined&#34;:
        if l1.slope() == &#34;undefined&#34; and min(l1.y1,l1.y2)&lt;l2.slope()*l1.x1+l2.intercept()&lt;max(l1.y1,l1.y2):
            x_intersection = l1.x1
        elif l2.slope() == &#34;undefined&#34; and min(l2.y1,l2.y2)&lt;l1.slope()*l2.x1+l1.intercept()&lt;max(l2.y1,l2.y2):
            x_intersection = l2.x1
        else:
            return False
    else:

        # round due to floating point arithmetic yielding incorrect results when the end of one line is equal to the
        # start of another line
        x_intersection = round((l2.intercept() - l1.intercept()) / (l1.slope() - l2.slope()), 5)

    # if x_intersection is within shared domain, return true
    if x_intersection &lt; max(min(l1.x1, l1.x2), min(l2.x1, l2.x2)) or x_intersection &gt; min(max(l1.x1, l1.x2), max(l2.x1, l2.x2)):
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.start_gui"><code class="name flex">
<span>def <span class="ident">start_gui</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a canvas window</p>
<p>Parameters:
none</p>
<p>Returns:
none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_gui():
    &#39;&#39;&#39;
    Opens a canvas window

    Parameters:
    none

    Returns:
    none
    &#39;&#39;&#39;
    mainloop()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="path_planning.boustrophedon_decomposition.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>x1, y1, x2, y2, identifier=0)</span>
</code></dt>
<dd>
<div class="desc"><p>straight line created by connecting [x1,y1] and [x2,y2]
tkinter returns a unique identifier when create_line is called
identifier can be used to delete the line later with canvas.delete(&hellip;)</p>
<p>Parameters:
x1: float
y1: float
x2: float
y2: float
identifier: int</p>
<p>Returns:
none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Line:
    &#39;&#39;&#39;
    straight line created by connecting [x1,y1] and [x2,y2]
    tkinter returns a unique identifier when create_line is called
    identifier can be used to delete the line later with canvas.delete(...)

    Parameters:
    x1: float
    y1: float
    x2: float
    y2: float
    identifier: int

    Returns:
    none
    &#39;&#39;&#39;

    def __init__(self, x1, y1, x2, y2, identifier=0):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.identifier = identifier

    def slope(self):
        &#39;&#39;&#39;
        uses rise/run formula to calculate slope
        returns string &#34;undefined&#34; and prints an error if the line is vertical

        Parameters:
        none

        Returns:
        none
        &#39;&#39;&#39;
        try:
            return (self.y2 - self.y1) / (self.x2 - self.x1)
        except ZeroDivisionError:
            #print(&#34;Divide by zero error&#34;)
            return &#34;undefined&#34;

    def intercept(self):
        &#39;&#39;&#39;
        uses y=mx+b -&gt; b=y-mx to calculate y-intercept
        returns string &#34;does not exist&#34; and prints an error if the line is vertical
        &#39;&#39;&#39;
        try:
            return self.y2 - self.slope() * self.x2
        except TypeError:
            print(&#34;Y-intercept does not exist due to undefined slope&#34;)
            return &#34;does not exist&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="path_planning.boustrophedon_decomposition.Line.intercept"><code class="name flex">
<span>def <span class="ident">intercept</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>uses y=mx+b -&gt; b=y-mx to calculate y-intercept
returns string "does not exist" and prints an error if the line is vertical</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intercept(self):
    &#39;&#39;&#39;
    uses y=mx+b -&gt; b=y-mx to calculate y-intercept
    returns string &#34;does not exist&#34; and prints an error if the line is vertical
    &#39;&#39;&#39;
    try:
        return self.y2 - self.slope() * self.x2
    except TypeError:
        print(&#34;Y-intercept does not exist due to undefined slope&#34;)
        return &#34;does not exist&#34;</code></pre>
</details>
</dd>
<dt id="path_planning.boustrophedon_decomposition.Line.slope"><code class="name flex">
<span>def <span class="ident">slope</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>uses rise/run formula to calculate slope
returns string "undefined" and prints an error if the line is vertical</p>
<p>Parameters:
none</p>
<p>Returns:
none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slope(self):
    &#39;&#39;&#39;
    uses rise/run formula to calculate slope
    returns string &#34;undefined&#34; and prints an error if the line is vertical

    Parameters:
    none

    Returns:
    none
    &#39;&#39;&#39;
    try:
        return (self.y2 - self.y1) / (self.x2 - self.x1)
    except ZeroDivisionError:
        #print(&#34;Divide by zero error&#34;)
        return &#34;undefined&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="path_planning" href="index.html">path_planning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="path_planning.boustrophedon_decomposition.boustrophedon_line_sweep" href="#path_planning.boustrophedon_decomposition.boustrophedon_line_sweep">boustrophedon_line_sweep</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.check_line_inside_boundary" href="#path_planning.boustrophedon_decomposition.check_line_inside_boundary">check_line_inside_boundary</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.coordinates_to_lines" href="#path_planning.boustrophedon_decomposition.coordinates_to_lines">coordinates_to_lines</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.cross_product" href="#path_planning.boustrophedon_decomposition.cross_product">cross_product</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.draw_boundary" href="#path_planning.boustrophedon_decomposition.draw_boundary">draw_boundary</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.extract_concave_vertices" href="#path_planning.boustrophedon_decomposition.extract_concave_vertices">extract_concave_vertices</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.extract_convex_vertices" href="#path_planning.boustrophedon_decomposition.extract_convex_vertices">extract_convex_vertices</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.init_gui" href="#path_planning.boustrophedon_decomposition.init_gui">init_gui</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.intersects" href="#path_planning.boustrophedon_decomposition.intersects">intersects</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.start_gui" href="#path_planning.boustrophedon_decomposition.start_gui">start_gui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="path_planning.boustrophedon_decomposition.Line" href="#path_planning.boustrophedon_decomposition.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="path_planning.boustrophedon_decomposition.Line.intercept" href="#path_planning.boustrophedon_decomposition.Line.intercept">intercept</a></code></li>
<li><code><a title="path_planning.boustrophedon_decomposition.Line.slope" href="#path_planning.boustrophedon_decomposition.Line.slope">slope</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>