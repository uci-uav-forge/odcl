<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>path_planning.sub_sweep API documentation</title>
<meta name="description" content="Grid based sweep planner â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>path_planning.sub_sweep</code></h1>
</header>
<section id="section-intro">
<p>Grid based sweep planner</p>
<p>original author: Atsushi Sakai
modifications made by: Rick Meade</p>
<p>This code is used and modified under MIT license.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Grid based sweep planner

original author: Atsushi Sakai
modifications made by: Rick Meade

This code is used and modified under MIT license.
&#34;&#34;&#34;
import math, os, sys
from enum import IntEnum
import numpy as np
from scipy.spatial.transform import Rotation as Rot
from grid_map_lib import GridMap
import matplotlib.pyplot as plt
from matplotlib.patches import PathPatch, Patch, Circle
import matplotlib

do_animation = True

class SweepSearcher:
    class SweepDirection(IntEnum):
        UP = 1
        DOWN = -1

    class MovingDirection(IntEnum):
        RIGHT = 1
        LEFT = -1

    def __init__(self, moving_direction, sweep_direction, x_inds_goal_y, goal_y):
        self.moving_direction = moving_direction
        self.sweep_direction = sweep_direction
        self.turing_window = []
        self.update_turning_window()
        self.x_indexes_goal_y = x_inds_goal_y
        self.goal_y = goal_y

    def move_target_grid(self, c_x_index, c_y_index, grid_map):
        n_x_index = self.moving_direction + c_x_index
        n_y_index = c_y_index
        # found safe grid
        if not grid_map.check_occupied_from_xy_index(n_x_index, n_y_index, occupied_val=0.5):
            return n_x_index, n_y_index
        else:  # occupied
            next_c_x_index, next_c_y_index = self.find_safe_turning_grid(
                c_x_index, c_y_index, grid_map)
            if (next_c_x_index is None) and (next_c_y_index is None):
                # moving backward
                next_c_x_index = -self.moving_direction + c_x_index
                next_c_y_index = c_y_index
                if grid_map.check_occupied_from_xy_index(next_c_x_index, next_c_y_index):
                    # moved backward, but the grid is occupied by obstacle
                    return None, None
            else:
                # keep moving until end
                while not grid_map.check_occupied_from_xy_index(
                        next_c_x_index + self.moving_direction,
                        next_c_y_index, occupied_val=0.5):
                    next_c_x_index += self.moving_direction
                self.swap_moving_direction()
            return next_c_x_index, next_c_y_index

    def find_safe_turning_grid(self, c_x_index, c_y_index, grid_map):
        for (d_x_ind, d_y_ind) in self.turing_window:
            next_x_ind = d_x_ind + c_x_index
            next_y_ind = d_y_ind + c_y_index
            # found safe grid
            if not grid_map.check_occupied_from_xy_index(next_x_ind, next_y_ind, occupied_val=0.5):
                return next_x_ind, next_y_ind
        return None, None

    def is_search_done(self, grid_map):
        for ix in self.x_indexes_goal_y:
            if not grid_map.check_occupied_from_xy_index(ix, self.goal_y, occupied_val=0.5):
                return False

        # all lower grid is occupied
        return True

    def update_turning_window(self):
        # turning window definition
        # robot can move grid based on it.
        self.turing_window = [
            (self.moving_direction, 0.0),
            (self.moving_direction, self.sweep_direction),
            (0, self.sweep_direction),
            (-self.moving_direction, self.sweep_direction),
        ]

    def swap_moving_direction(self):
        self.moving_direction *= -1
        self.update_turning_window()

    def search_start_grid(self, grid_map):
        x_inds = []
        y_ind = 0
        sweeper = Sweep()
        if self.sweep_direction == self.SweepDirection.DOWN:
            x_inds, y_ind = sweeper.search_free_grid_index_at_edge_y(grid_map, from_upper=True)
        elif self.sweep_direction == self.SweepDirection.UP:
            x_inds, y_ind = sweeper.search_free_grid_index_at_edge_y(grid_map, from_upper=False)
        if self.moving_direction == self.MovingDirection.RIGHT:
            if x_inds:
                return min(x_inds), y_ind
            else:
                return None
        elif self.moving_direction == self.MovingDirection.LEFT:
            if x_inds:
                return max(x_inds), y_ind
            else:
                return None
        raise ValueError(&#34;self.moving direction is invalid &#34;)

class Sweep(object):
    def __init__(self, use_theta=False, theta=0):
        self.use_theta = use_theta
        self.theta = theta

    def find_sweep_direction_and_start_position(self, ox, oy):
        # sweep direction and position. 
        # position is the xy pair of the terminal node on cell border
        # direction is the dx/dy of the last (largest) cell direction
        max_dist = 0.0
        vec = [0.0, 0.0]
        sweep_start_pos = [0.0, 0.0]
        for i in range(len(ox) - 1):
            dx = ox[i + 1] - ox[i]
            dy = oy[i + 1] - oy[i]
            d = np.hypot(dx, dy)
            if d &gt; max_dist:
                max_dist = d
                if self.use_theta:
                    vec = [np.sin(self.theta), np.cos(self.theta)]
                else:
                    vec = [dx, dy]
                sweep_start_pos = [ox[i], oy[i]]
        return vec, sweep_start_pos


    def convert_grid_coordinate(self, ox, oy, sweep_vec, sweep_start_position):
        tx = [ix - sweep_start_position[0] for ix in ox]
        ty = [iy - sweep_start_position[1] for iy in oy]
        th = math.atan2(sweep_vec[1], sweep_vec[0])
        rot = Rot.from_euler(&#39;z&#39;, th).as_matrix()[0:2, 0:2]
        converted_xy = np.stack([tx, ty]).T @ rot
        return converted_xy[:, 0], converted_xy[:, 1]


    def convert_global_coordinate(self, x, y, sweep_vec, sweep_start_position):
        th = math.atan2(sweep_vec[1], sweep_vec[0])
        rot = Rot.from_euler(&#39;z&#39;, -th).as_matrix()[0:2, 0:2]
        converted_xy = np.stack([x, y]).T @ rot
        rx = [ix + sweep_start_position[0] for ix in converted_xy[:, 0]]
        ry = [iy + sweep_start_position[1] for iy in converted_xy[:, 1]]
        return rx, ry

    def search_free_grid_index_at_edge_y(self, grid_map, from_upper=False):
        y_index = None
        x_indexes = []

        if from_upper:
            x_range = range(grid_map.height)[::-1]
            y_range = range(grid_map.width)[::-1]
        else:
            x_range = range(grid_map.height)
            y_range = range(grid_map.width)

        for iy in x_range:
            for ix in y_range:
                if not grid_map.check_occupied_from_xy_index(ix, iy):
                    y_index = iy
                    x_indexes.append(ix)
            if y_index:
                break

        return x_indexes, y_index

    def setup_grid_map(self, ox, oy, resolution, sweep_direction, offset_grid=10):
        width = math.ceil((max(ox) - min(ox)) / resolution) + offset_grid
        height = math.ceil((max(oy) - min(oy)) / resolution) + offset_grid
        center_x = (np.max(ox) + np.min(ox)) / 2.0
        center_y = (np.max(oy) + np.min(oy)) / 2.0

        grid_map = GridMap(width, height, resolution, center_x, center_y)
        grid_map.set_value_from_polygon(ox.tolist(), oy.tolist(), 1.0, inside=False)
        grid_map.expand_grid()

        x_inds_goal_y = []
        goal_y = 0
        if sweep_direction == SweepSearcher.SweepDirection.UP:
            x_inds_goal_y, goal_y = self.search_free_grid_index_at_edge_y(grid_map, from_upper=True)
        elif sweep_direction == SweepSearcher.SweepDirection.DOWN:
            x_inds_goal_y, goal_y = self.search_free_grid_index_at_edge_y(grid_map, from_upper=False)
        return grid_map, x_inds_goal_y, goal_y


    def sweep_path_search(self, sweep_searcher, grid_map, grid_search_animation=False, **kwargs):
        # search start grid
        idxs = sweep_searcher.search_start_grid(grid_map)
        if idxs:
            c_x_index, c_y_index = idxs
            if not grid_map.set_value_from_xy_index(c_x_index, c_y_index, 0.5):
                return [], []

            x, y = grid_map.calc_grid_central_xy_position_from_xy_index(c_x_index, c_y_index)
            px, py = [x], [y]
        else:
            px = []
            py = []
        if idxs:
            while True:
                c_x_index, c_y_index = sweep_searcher.move_target_grid(c_x_index, c_y_index, grid_map)
                if sweep_searcher.is_search_done(grid_map) or (
                        c_x_index is None or c_y_index is None):
                    break
                x, y = grid_map.calc_grid_central_xy_position_from_xy_index(
                    c_x_index, c_y_index)
                px.append(x)
                py.append(y)
                grid_map.set_value_from_xy_index(c_x_index, c_y_index, 0.5)
        return px, py

    def planning(self, ox, oy, resolution, moving_direction=SweepSearcher.MovingDirection.RIGHT, sweeping_direction=SweepSearcher.SweepDirection.UP):
        sweep_vec, sweep_start_position = self.find_sweep_direction_and_start_position(ox, oy)
        rox, roy = self.convert_grid_coordinate(ox, oy, sweep_vec, sweep_start_position)
        grid_map, x_inds_goal_y, goal_y = self.setup_grid_map(rox, roy, resolution, sweeping_direction)
        sweep_searcher = SweepSearcher(moving_direction, sweeping_direction, x_inds_goal_y, goal_y)
        px, py = self.sweep_path_search(sweep_searcher, grid_map)
        rx, ry = self.convert_global_coordinate(px, py, sweep_vec, sweep_start_position)
        return rx, ry

    def sweep(self, coords, width, flip_path = False):
        ox = []
        oy = []
        waypoints = []

        for x in coords:
            ox.append(x[0])
            oy.append(x[1])
        ox.append(coords[0][0])
        oy.append(coords[0][1])

        px, py = planning(ox, oy, width)
        for rx, ry in zip(px, py):
            waypoints.append([rx, ry])
        if flip_path:
            return waypoints.reverse()
        else:
            return waypoints

class PathAnimator(object):
    def __init__(self, path_color=&#39;blue&#39;):
        self.path_color = path_color

    def animate(self, path, world, fig, ax1, ax2, save=False, **kwargs):
        rg_node = []
        # for each path that sweeps a cell, pair every cell_sweep_path point with the
        # vertex cellv of the corresponding cell
        for cell_sweep_path, cellv in path:
            rg_node.extend([cellv] * cell_sweep_path.shape[0])
        # the path is now in p[0], every vertex is now in p[1]

        # get raw path
        path = np.concatenate([p[0] for p in path], axis=0)

        path_line = matplotlib.lines.Line2D(
            path[:,0],
            path[:,1],
            animated=True,
            antialiased=True,
            color=self.path_color,
            linewidth=0.5,
            linestyle=&#39;-&#39;,
            marker=&#39;.&#39;,
        )
        scale = (ax2.get_xlim()[1] - ax2.get_xlim()[0]) * 0.02
        rg_circle = matplotlib.patches.Ellipse(
            (1e5,1e5),
            width=scale,
            height=scale,
            animated=True,
            fill=True,
            hatch=&#39;+&#39;,
            zorder=4,
            linewidth=None,
            color=self.path_color,
        )

        frames = path.shape[0]
        def initframe():
            ax1.add_artist(path_line)
            ax2.add_patch(rg_circle)
            return path_line, rg_circle
            
        def drawframe(i):
            ax1.draw_artist(path_line)
            path_line.set_xdata(path[:i,0])
            path_line.set_ydata(path[:i,1])
            ax2.draw_artist(rg_circle)
            pts = np.array(world.points)
            rg_center = world.Rg.nodes[rg_node[i]][&#39;center&#39;]
            rg_circle.set_center((rg_center[0], rg_center[1]))
            return path_line, rg_circle


        if save:
            # for some reason, calling plt.show() makes saving the animation possible... I don&#39;t get it but whatever
            plt.show()
            plt.close()
            ani = matplotlib.animation.FuncAnimation(fig, drawframe, frames=frames, init_func=initframe, interval=1, blit=True)
        else:
            ani = matplotlib.animation.FuncAnimation(fig, drawframe, frames=frames, init_func=initframe, interval=1, blit=True)
            
        if save:
            if &#39;savepath&#39; not in kwargs:
                raise(Exception(&#39;Must include a save path, pass a str `path` in.&#39;))
            ani.save(kwargs[&#39;savepath&#39;], writer=&#39;ffmpeg&#39;, fps=30)
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="path_planning.sub_sweep.PathAnimator"><code class="flex name class">
<span>class <span class="ident">PathAnimator</span></span>
<span>(</span><span>path_color='blue')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PathAnimator(object):
    def __init__(self, path_color=&#39;blue&#39;):
        self.path_color = path_color

    def animate(self, path, world, fig, ax1, ax2, save=False, **kwargs):
        rg_node = []
        # for each path that sweeps a cell, pair every cell_sweep_path point with the
        # vertex cellv of the corresponding cell
        for cell_sweep_path, cellv in path:
            rg_node.extend([cellv] * cell_sweep_path.shape[0])
        # the path is now in p[0], every vertex is now in p[1]

        # get raw path
        path = np.concatenate([p[0] for p in path], axis=0)

        path_line = matplotlib.lines.Line2D(
            path[:,0],
            path[:,1],
            animated=True,
            antialiased=True,
            color=self.path_color,
            linewidth=0.5,
            linestyle=&#39;-&#39;,
            marker=&#39;.&#39;,
        )
        scale = (ax2.get_xlim()[1] - ax2.get_xlim()[0]) * 0.02
        rg_circle = matplotlib.patches.Ellipse(
            (1e5,1e5),
            width=scale,
            height=scale,
            animated=True,
            fill=True,
            hatch=&#39;+&#39;,
            zorder=4,
            linewidth=None,
            color=self.path_color,
        )

        frames = path.shape[0]
        def initframe():
            ax1.add_artist(path_line)
            ax2.add_patch(rg_circle)
            return path_line, rg_circle
            
        def drawframe(i):
            ax1.draw_artist(path_line)
            path_line.set_xdata(path[:i,0])
            path_line.set_ydata(path[:i,1])
            ax2.draw_artist(rg_circle)
            pts = np.array(world.points)
            rg_center = world.Rg.nodes[rg_node[i]][&#39;center&#39;]
            rg_circle.set_center((rg_center[0], rg_center[1]))
            return path_line, rg_circle


        if save:
            # for some reason, calling plt.show() makes saving the animation possible... I don&#39;t get it but whatever
            plt.show()
            plt.close()
            ani = matplotlib.animation.FuncAnimation(fig, drawframe, frames=frames, init_func=initframe, interval=1, blit=True)
        else:
            ani = matplotlib.animation.FuncAnimation(fig, drawframe, frames=frames, init_func=initframe, interval=1, blit=True)
            
        if save:
            if &#39;savepath&#39; not in kwargs:
                raise(Exception(&#39;Must include a save path, pass a str `path` in.&#39;))
            ani.save(kwargs[&#39;savepath&#39;], writer=&#39;ffmpeg&#39;, fps=30)
        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="path_planning.sub_sweep.PathAnimator.animate"><code class="name flex">
<span>def <span class="ident">animate</span></span>(<span>self, path, world, fig, ax1, ax2, save=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate(self, path, world, fig, ax1, ax2, save=False, **kwargs):
    rg_node = []
    # for each path that sweeps a cell, pair every cell_sweep_path point with the
    # vertex cellv of the corresponding cell
    for cell_sweep_path, cellv in path:
        rg_node.extend([cellv] * cell_sweep_path.shape[0])
    # the path is now in p[0], every vertex is now in p[1]

    # get raw path
    path = np.concatenate([p[0] for p in path], axis=0)

    path_line = matplotlib.lines.Line2D(
        path[:,0],
        path[:,1],
        animated=True,
        antialiased=True,
        color=self.path_color,
        linewidth=0.5,
        linestyle=&#39;-&#39;,
        marker=&#39;.&#39;,
    )
    scale = (ax2.get_xlim()[1] - ax2.get_xlim()[0]) * 0.02
    rg_circle = matplotlib.patches.Ellipse(
        (1e5,1e5),
        width=scale,
        height=scale,
        animated=True,
        fill=True,
        hatch=&#39;+&#39;,
        zorder=4,
        linewidth=None,
        color=self.path_color,
    )

    frames = path.shape[0]
    def initframe():
        ax1.add_artist(path_line)
        ax2.add_patch(rg_circle)
        return path_line, rg_circle
        
    def drawframe(i):
        ax1.draw_artist(path_line)
        path_line.set_xdata(path[:i,0])
        path_line.set_ydata(path[:i,1])
        ax2.draw_artist(rg_circle)
        pts = np.array(world.points)
        rg_center = world.Rg.nodes[rg_node[i]][&#39;center&#39;]
        rg_circle.set_center((rg_center[0], rg_center[1]))
        return path_line, rg_circle


    if save:
        # for some reason, calling plt.show() makes saving the animation possible... I don&#39;t get it but whatever
        plt.show()
        plt.close()
        ani = matplotlib.animation.FuncAnimation(fig, drawframe, frames=frames, init_func=initframe, interval=1, blit=True)
    else:
        ani = matplotlib.animation.FuncAnimation(fig, drawframe, frames=frames, init_func=initframe, interval=1, blit=True)
        
    if save:
        if &#39;savepath&#39; not in kwargs:
            raise(Exception(&#39;Must include a save path, pass a str `path` in.&#39;))
        ani.save(kwargs[&#39;savepath&#39;], writer=&#39;ffmpeg&#39;, fps=30)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="path_planning.sub_sweep.Sweep"><code class="flex name class">
<span>class <span class="ident">Sweep</span></span>
<span>(</span><span>use_theta=False, theta=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sweep(object):
    def __init__(self, use_theta=False, theta=0):
        self.use_theta = use_theta
        self.theta = theta

    def find_sweep_direction_and_start_position(self, ox, oy):
        # sweep direction and position. 
        # position is the xy pair of the terminal node on cell border
        # direction is the dx/dy of the last (largest) cell direction
        max_dist = 0.0
        vec = [0.0, 0.0]
        sweep_start_pos = [0.0, 0.0]
        for i in range(len(ox) - 1):
            dx = ox[i + 1] - ox[i]
            dy = oy[i + 1] - oy[i]
            d = np.hypot(dx, dy)
            if d &gt; max_dist:
                max_dist = d
                if self.use_theta:
                    vec = [np.sin(self.theta), np.cos(self.theta)]
                else:
                    vec = [dx, dy]
                sweep_start_pos = [ox[i], oy[i]]
        return vec, sweep_start_pos


    def convert_grid_coordinate(self, ox, oy, sweep_vec, sweep_start_position):
        tx = [ix - sweep_start_position[0] for ix in ox]
        ty = [iy - sweep_start_position[1] for iy in oy]
        th = math.atan2(sweep_vec[1], sweep_vec[0])
        rot = Rot.from_euler(&#39;z&#39;, th).as_matrix()[0:2, 0:2]
        converted_xy = np.stack([tx, ty]).T @ rot
        return converted_xy[:, 0], converted_xy[:, 1]


    def convert_global_coordinate(self, x, y, sweep_vec, sweep_start_position):
        th = math.atan2(sweep_vec[1], sweep_vec[0])
        rot = Rot.from_euler(&#39;z&#39;, -th).as_matrix()[0:2, 0:2]
        converted_xy = np.stack([x, y]).T @ rot
        rx = [ix + sweep_start_position[0] for ix in converted_xy[:, 0]]
        ry = [iy + sweep_start_position[1] for iy in converted_xy[:, 1]]
        return rx, ry

    def search_free_grid_index_at_edge_y(self, grid_map, from_upper=False):
        y_index = None
        x_indexes = []

        if from_upper:
            x_range = range(grid_map.height)[::-1]
            y_range = range(grid_map.width)[::-1]
        else:
            x_range = range(grid_map.height)
            y_range = range(grid_map.width)

        for iy in x_range:
            for ix in y_range:
                if not grid_map.check_occupied_from_xy_index(ix, iy):
                    y_index = iy
                    x_indexes.append(ix)
            if y_index:
                break

        return x_indexes, y_index

    def setup_grid_map(self, ox, oy, resolution, sweep_direction, offset_grid=10):
        width = math.ceil((max(ox) - min(ox)) / resolution) + offset_grid
        height = math.ceil((max(oy) - min(oy)) / resolution) + offset_grid
        center_x = (np.max(ox) + np.min(ox)) / 2.0
        center_y = (np.max(oy) + np.min(oy)) / 2.0

        grid_map = GridMap(width, height, resolution, center_x, center_y)
        grid_map.set_value_from_polygon(ox.tolist(), oy.tolist(), 1.0, inside=False)
        grid_map.expand_grid()

        x_inds_goal_y = []
        goal_y = 0
        if sweep_direction == SweepSearcher.SweepDirection.UP:
            x_inds_goal_y, goal_y = self.search_free_grid_index_at_edge_y(grid_map, from_upper=True)
        elif sweep_direction == SweepSearcher.SweepDirection.DOWN:
            x_inds_goal_y, goal_y = self.search_free_grid_index_at_edge_y(grid_map, from_upper=False)
        return grid_map, x_inds_goal_y, goal_y


    def sweep_path_search(self, sweep_searcher, grid_map, grid_search_animation=False, **kwargs):
        # search start grid
        idxs = sweep_searcher.search_start_grid(grid_map)
        if idxs:
            c_x_index, c_y_index = idxs
            if not grid_map.set_value_from_xy_index(c_x_index, c_y_index, 0.5):
                return [], []

            x, y = grid_map.calc_grid_central_xy_position_from_xy_index(c_x_index, c_y_index)
            px, py = [x], [y]
        else:
            px = []
            py = []
        if idxs:
            while True:
                c_x_index, c_y_index = sweep_searcher.move_target_grid(c_x_index, c_y_index, grid_map)
                if sweep_searcher.is_search_done(grid_map) or (
                        c_x_index is None or c_y_index is None):
                    break
                x, y = grid_map.calc_grid_central_xy_position_from_xy_index(
                    c_x_index, c_y_index)
                px.append(x)
                py.append(y)
                grid_map.set_value_from_xy_index(c_x_index, c_y_index, 0.5)
        return px, py

    def planning(self, ox, oy, resolution, moving_direction=SweepSearcher.MovingDirection.RIGHT, sweeping_direction=SweepSearcher.SweepDirection.UP):
        sweep_vec, sweep_start_position = self.find_sweep_direction_and_start_position(ox, oy)
        rox, roy = self.convert_grid_coordinate(ox, oy, sweep_vec, sweep_start_position)
        grid_map, x_inds_goal_y, goal_y = self.setup_grid_map(rox, roy, resolution, sweeping_direction)
        sweep_searcher = SweepSearcher(moving_direction, sweeping_direction, x_inds_goal_y, goal_y)
        px, py = self.sweep_path_search(sweep_searcher, grid_map)
        rx, ry = self.convert_global_coordinate(px, py, sweep_vec, sweep_start_position)
        return rx, ry

    def sweep(self, coords, width, flip_path = False):
        ox = []
        oy = []
        waypoints = []

        for x in coords:
            ox.append(x[0])
            oy.append(x[1])
        ox.append(coords[0][0])
        oy.append(coords[0][1])

        px, py = planning(ox, oy, width)
        for rx, ry in zip(px, py):
            waypoints.append([rx, ry])
        if flip_path:
            return waypoints.reverse()
        else:
            return waypoints</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="path_planning.sub_sweep.Sweep.convert_global_coordinate"><code class="name flex">
<span>def <span class="ident">convert_global_coordinate</span></span>(<span>self, x, y, sweep_vec, sweep_start_position)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_global_coordinate(self, x, y, sweep_vec, sweep_start_position):
    th = math.atan2(sweep_vec[1], sweep_vec[0])
    rot = Rot.from_euler(&#39;z&#39;, -th).as_matrix()[0:2, 0:2]
    converted_xy = np.stack([x, y]).T @ rot
    rx = [ix + sweep_start_position[0] for ix in converted_xy[:, 0]]
    ry = [iy + sweep_start_position[1] for iy in converted_xy[:, 1]]
    return rx, ry</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.Sweep.convert_grid_coordinate"><code class="name flex">
<span>def <span class="ident">convert_grid_coordinate</span></span>(<span>self, ox, oy, sweep_vec, sweep_start_position)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_grid_coordinate(self, ox, oy, sweep_vec, sweep_start_position):
    tx = [ix - sweep_start_position[0] for ix in ox]
    ty = [iy - sweep_start_position[1] for iy in oy]
    th = math.atan2(sweep_vec[1], sweep_vec[0])
    rot = Rot.from_euler(&#39;z&#39;, th).as_matrix()[0:2, 0:2]
    converted_xy = np.stack([tx, ty]).T @ rot
    return converted_xy[:, 0], converted_xy[:, 1]</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.Sweep.find_sweep_direction_and_start_position"><code class="name flex">
<span>def <span class="ident">find_sweep_direction_and_start_position</span></span>(<span>self, ox, oy)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_sweep_direction_and_start_position(self, ox, oy):
    # sweep direction and position. 
    # position is the xy pair of the terminal node on cell border
    # direction is the dx/dy of the last (largest) cell direction
    max_dist = 0.0
    vec = [0.0, 0.0]
    sweep_start_pos = [0.0, 0.0]
    for i in range(len(ox) - 1):
        dx = ox[i + 1] - ox[i]
        dy = oy[i + 1] - oy[i]
        d = np.hypot(dx, dy)
        if d &gt; max_dist:
            max_dist = d
            if self.use_theta:
                vec = [np.sin(self.theta), np.cos(self.theta)]
            else:
                vec = [dx, dy]
            sweep_start_pos = [ox[i], oy[i]]
    return vec, sweep_start_pos</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.Sweep.planning"><code class="name flex">
<span>def <span class="ident">planning</span></span>(<span>self, ox, oy, resolution, moving_direction=MovingDirection.RIGHT, sweeping_direction=SweepDirection.UP)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def planning(self, ox, oy, resolution, moving_direction=SweepSearcher.MovingDirection.RIGHT, sweeping_direction=SweepSearcher.SweepDirection.UP):
    sweep_vec, sweep_start_position = self.find_sweep_direction_and_start_position(ox, oy)
    rox, roy = self.convert_grid_coordinate(ox, oy, sweep_vec, sweep_start_position)
    grid_map, x_inds_goal_y, goal_y = self.setup_grid_map(rox, roy, resolution, sweeping_direction)
    sweep_searcher = SweepSearcher(moving_direction, sweeping_direction, x_inds_goal_y, goal_y)
    px, py = self.sweep_path_search(sweep_searcher, grid_map)
    rx, ry = self.convert_global_coordinate(px, py, sweep_vec, sweep_start_position)
    return rx, ry</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.Sweep.search_free_grid_index_at_edge_y"><code class="name flex">
<span>def <span class="ident">search_free_grid_index_at_edge_y</span></span>(<span>self, grid_map, from_upper=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_free_grid_index_at_edge_y(self, grid_map, from_upper=False):
    y_index = None
    x_indexes = []

    if from_upper:
        x_range = range(grid_map.height)[::-1]
        y_range = range(grid_map.width)[::-1]
    else:
        x_range = range(grid_map.height)
        y_range = range(grid_map.width)

    for iy in x_range:
        for ix in y_range:
            if not grid_map.check_occupied_from_xy_index(ix, iy):
                y_index = iy
                x_indexes.append(ix)
        if y_index:
            break

    return x_indexes, y_index</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.Sweep.setup_grid_map"><code class="name flex">
<span>def <span class="ident">setup_grid_map</span></span>(<span>self, ox, oy, resolution, sweep_direction, offset_grid=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_grid_map(self, ox, oy, resolution, sweep_direction, offset_grid=10):
    width = math.ceil((max(ox) - min(ox)) / resolution) + offset_grid
    height = math.ceil((max(oy) - min(oy)) / resolution) + offset_grid
    center_x = (np.max(ox) + np.min(ox)) / 2.0
    center_y = (np.max(oy) + np.min(oy)) / 2.0

    grid_map = GridMap(width, height, resolution, center_x, center_y)
    grid_map.set_value_from_polygon(ox.tolist(), oy.tolist(), 1.0, inside=False)
    grid_map.expand_grid()

    x_inds_goal_y = []
    goal_y = 0
    if sweep_direction == SweepSearcher.SweepDirection.UP:
        x_inds_goal_y, goal_y = self.search_free_grid_index_at_edge_y(grid_map, from_upper=True)
    elif sweep_direction == SweepSearcher.SweepDirection.DOWN:
        x_inds_goal_y, goal_y = self.search_free_grid_index_at_edge_y(grid_map, from_upper=False)
    return grid_map, x_inds_goal_y, goal_y</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.Sweep.sweep"><code class="name flex">
<span>def <span class="ident">sweep</span></span>(<span>self, coords, width, flip_path=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sweep(self, coords, width, flip_path = False):
    ox = []
    oy = []
    waypoints = []

    for x in coords:
        ox.append(x[0])
        oy.append(x[1])
    ox.append(coords[0][0])
    oy.append(coords[0][1])

    px, py = planning(ox, oy, width)
    for rx, ry in zip(px, py):
        waypoints.append([rx, ry])
    if flip_path:
        return waypoints.reverse()
    else:
        return waypoints</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.Sweep.sweep_path_search"><code class="name flex">
<span>def <span class="ident">sweep_path_search</span></span>(<span>self, sweep_searcher, grid_map, grid_search_animation=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sweep_path_search(self, sweep_searcher, grid_map, grid_search_animation=False, **kwargs):
    # search start grid
    idxs = sweep_searcher.search_start_grid(grid_map)
    if idxs:
        c_x_index, c_y_index = idxs
        if not grid_map.set_value_from_xy_index(c_x_index, c_y_index, 0.5):
            return [], []

        x, y = grid_map.calc_grid_central_xy_position_from_xy_index(c_x_index, c_y_index)
        px, py = [x], [y]
    else:
        px = []
        py = []
    if idxs:
        while True:
            c_x_index, c_y_index = sweep_searcher.move_target_grid(c_x_index, c_y_index, grid_map)
            if sweep_searcher.is_search_done(grid_map) or (
                    c_x_index is None or c_y_index is None):
                break
            x, y = grid_map.calc_grid_central_xy_position_from_xy_index(
                c_x_index, c_y_index)
            px.append(x)
            py.append(y)
            grid_map.set_value_from_xy_index(c_x_index, c_y_index, 0.5)
    return px, py</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="path_planning.sub_sweep.SweepSearcher"><code class="flex name class">
<span>class <span class="ident">SweepSearcher</span></span>
<span>(</span><span>moving_direction, sweep_direction, x_inds_goal_y, goal_y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SweepSearcher:
    class SweepDirection(IntEnum):
        UP = 1
        DOWN = -1

    class MovingDirection(IntEnum):
        RIGHT = 1
        LEFT = -1

    def __init__(self, moving_direction, sweep_direction, x_inds_goal_y, goal_y):
        self.moving_direction = moving_direction
        self.sweep_direction = sweep_direction
        self.turing_window = []
        self.update_turning_window()
        self.x_indexes_goal_y = x_inds_goal_y
        self.goal_y = goal_y

    def move_target_grid(self, c_x_index, c_y_index, grid_map):
        n_x_index = self.moving_direction + c_x_index
        n_y_index = c_y_index
        # found safe grid
        if not grid_map.check_occupied_from_xy_index(n_x_index, n_y_index, occupied_val=0.5):
            return n_x_index, n_y_index
        else:  # occupied
            next_c_x_index, next_c_y_index = self.find_safe_turning_grid(
                c_x_index, c_y_index, grid_map)
            if (next_c_x_index is None) and (next_c_y_index is None):
                # moving backward
                next_c_x_index = -self.moving_direction + c_x_index
                next_c_y_index = c_y_index
                if grid_map.check_occupied_from_xy_index(next_c_x_index, next_c_y_index):
                    # moved backward, but the grid is occupied by obstacle
                    return None, None
            else:
                # keep moving until end
                while not grid_map.check_occupied_from_xy_index(
                        next_c_x_index + self.moving_direction,
                        next_c_y_index, occupied_val=0.5):
                    next_c_x_index += self.moving_direction
                self.swap_moving_direction()
            return next_c_x_index, next_c_y_index

    def find_safe_turning_grid(self, c_x_index, c_y_index, grid_map):
        for (d_x_ind, d_y_ind) in self.turing_window:
            next_x_ind = d_x_ind + c_x_index
            next_y_ind = d_y_ind + c_y_index
            # found safe grid
            if not grid_map.check_occupied_from_xy_index(next_x_ind, next_y_ind, occupied_val=0.5):
                return next_x_ind, next_y_ind
        return None, None

    def is_search_done(self, grid_map):
        for ix in self.x_indexes_goal_y:
            if not grid_map.check_occupied_from_xy_index(ix, self.goal_y, occupied_val=0.5):
                return False

        # all lower grid is occupied
        return True

    def update_turning_window(self):
        # turning window definition
        # robot can move grid based on it.
        self.turing_window = [
            (self.moving_direction, 0.0),
            (self.moving_direction, self.sweep_direction),
            (0, self.sweep_direction),
            (-self.moving_direction, self.sweep_direction),
        ]

    def swap_moving_direction(self):
        self.moving_direction *= -1
        self.update_turning_window()

    def search_start_grid(self, grid_map):
        x_inds = []
        y_ind = 0
        sweeper = Sweep()
        if self.sweep_direction == self.SweepDirection.DOWN:
            x_inds, y_ind = sweeper.search_free_grid_index_at_edge_y(grid_map, from_upper=True)
        elif self.sweep_direction == self.SweepDirection.UP:
            x_inds, y_ind = sweeper.search_free_grid_index_at_edge_y(grid_map, from_upper=False)
        if self.moving_direction == self.MovingDirection.RIGHT:
            if x_inds:
                return min(x_inds), y_ind
            else:
                return None
        elif self.moving_direction == self.MovingDirection.LEFT:
            if x_inds:
                return max(x_inds), y_ind
            else:
                return None
        raise ValueError(&#34;self.moving direction is invalid &#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="path_planning.sub_sweep.SweepSearcher.MovingDirection"><code class="name">var <span class="ident">MovingDirection</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="path_planning.sub_sweep.SweepSearcher.SweepDirection"><code class="name">var <span class="ident">SweepDirection</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="path_planning.sub_sweep.SweepSearcher.find_safe_turning_grid"><code class="name flex">
<span>def <span class="ident">find_safe_turning_grid</span></span>(<span>self, c_x_index, c_y_index, grid_map)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_safe_turning_grid(self, c_x_index, c_y_index, grid_map):
    for (d_x_ind, d_y_ind) in self.turing_window:
        next_x_ind = d_x_ind + c_x_index
        next_y_ind = d_y_ind + c_y_index
        # found safe grid
        if not grid_map.check_occupied_from_xy_index(next_x_ind, next_y_ind, occupied_val=0.5):
            return next_x_ind, next_y_ind
    return None, None</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.SweepSearcher.is_search_done"><code class="name flex">
<span>def <span class="ident">is_search_done</span></span>(<span>self, grid_map)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_search_done(self, grid_map):
    for ix in self.x_indexes_goal_y:
        if not grid_map.check_occupied_from_xy_index(ix, self.goal_y, occupied_val=0.5):
            return False

    # all lower grid is occupied
    return True</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.SweepSearcher.move_target_grid"><code class="name flex">
<span>def <span class="ident">move_target_grid</span></span>(<span>self, c_x_index, c_y_index, grid_map)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_target_grid(self, c_x_index, c_y_index, grid_map):
    n_x_index = self.moving_direction + c_x_index
    n_y_index = c_y_index
    # found safe grid
    if not grid_map.check_occupied_from_xy_index(n_x_index, n_y_index, occupied_val=0.5):
        return n_x_index, n_y_index
    else:  # occupied
        next_c_x_index, next_c_y_index = self.find_safe_turning_grid(
            c_x_index, c_y_index, grid_map)
        if (next_c_x_index is None) and (next_c_y_index is None):
            # moving backward
            next_c_x_index = -self.moving_direction + c_x_index
            next_c_y_index = c_y_index
            if grid_map.check_occupied_from_xy_index(next_c_x_index, next_c_y_index):
                # moved backward, but the grid is occupied by obstacle
                return None, None
        else:
            # keep moving until end
            while not grid_map.check_occupied_from_xy_index(
                    next_c_x_index + self.moving_direction,
                    next_c_y_index, occupied_val=0.5):
                next_c_x_index += self.moving_direction
            self.swap_moving_direction()
        return next_c_x_index, next_c_y_index</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.SweepSearcher.search_start_grid"><code class="name flex">
<span>def <span class="ident">search_start_grid</span></span>(<span>self, grid_map)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_start_grid(self, grid_map):
    x_inds = []
    y_ind = 0
    sweeper = Sweep()
    if self.sweep_direction == self.SweepDirection.DOWN:
        x_inds, y_ind = sweeper.search_free_grid_index_at_edge_y(grid_map, from_upper=True)
    elif self.sweep_direction == self.SweepDirection.UP:
        x_inds, y_ind = sweeper.search_free_grid_index_at_edge_y(grid_map, from_upper=False)
    if self.moving_direction == self.MovingDirection.RIGHT:
        if x_inds:
            return min(x_inds), y_ind
        else:
            return None
    elif self.moving_direction == self.MovingDirection.LEFT:
        if x_inds:
            return max(x_inds), y_ind
        else:
            return None
    raise ValueError(&#34;self.moving direction is invalid &#34;)</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.SweepSearcher.swap_moving_direction"><code class="name flex">
<span>def <span class="ident">swap_moving_direction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_moving_direction(self):
    self.moving_direction *= -1
    self.update_turning_window()</code></pre>
</details>
</dd>
<dt id="path_planning.sub_sweep.SweepSearcher.update_turning_window"><code class="name flex">
<span>def <span class="ident">update_turning_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_turning_window(self):
    # turning window definition
    # robot can move grid based on it.
    self.turing_window = [
        (self.moving_direction, 0.0),
        (self.moving_direction, self.sweep_direction),
        (0, self.sweep_direction),
        (-self.moving_direction, self.sweep_direction),
    ]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="path_planning" href="index.html">path_planning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="path_planning.sub_sweep.PathAnimator" href="#path_planning.sub_sweep.PathAnimator">PathAnimator</a></code></h4>
<ul class="">
<li><code><a title="path_planning.sub_sweep.PathAnimator.animate" href="#path_planning.sub_sweep.PathAnimator.animate">animate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="path_planning.sub_sweep.Sweep" href="#path_planning.sub_sweep.Sweep">Sweep</a></code></h4>
<ul class="">
<li><code><a title="path_planning.sub_sweep.Sweep.convert_global_coordinate" href="#path_planning.sub_sweep.Sweep.convert_global_coordinate">convert_global_coordinate</a></code></li>
<li><code><a title="path_planning.sub_sweep.Sweep.convert_grid_coordinate" href="#path_planning.sub_sweep.Sweep.convert_grid_coordinate">convert_grid_coordinate</a></code></li>
<li><code><a title="path_planning.sub_sweep.Sweep.find_sweep_direction_and_start_position" href="#path_planning.sub_sweep.Sweep.find_sweep_direction_and_start_position">find_sweep_direction_and_start_position</a></code></li>
<li><code><a title="path_planning.sub_sweep.Sweep.planning" href="#path_planning.sub_sweep.Sweep.planning">planning</a></code></li>
<li><code><a title="path_planning.sub_sweep.Sweep.search_free_grid_index_at_edge_y" href="#path_planning.sub_sweep.Sweep.search_free_grid_index_at_edge_y">search_free_grid_index_at_edge_y</a></code></li>
<li><code><a title="path_planning.sub_sweep.Sweep.setup_grid_map" href="#path_planning.sub_sweep.Sweep.setup_grid_map">setup_grid_map</a></code></li>
<li><code><a title="path_planning.sub_sweep.Sweep.sweep" href="#path_planning.sub_sweep.Sweep.sweep">sweep</a></code></li>
<li><code><a title="path_planning.sub_sweep.Sweep.sweep_path_search" href="#path_planning.sub_sweep.Sweep.sweep_path_search">sweep_path_search</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="path_planning.sub_sweep.SweepSearcher" href="#path_planning.sub_sweep.SweepSearcher">SweepSearcher</a></code></h4>
<ul class="">
<li><code><a title="path_planning.sub_sweep.SweepSearcher.MovingDirection" href="#path_planning.sub_sweep.SweepSearcher.MovingDirection">MovingDirection</a></code></li>
<li><code><a title="path_planning.sub_sweep.SweepSearcher.SweepDirection" href="#path_planning.sub_sweep.SweepSearcher.SweepDirection">SweepDirection</a></code></li>
<li><code><a title="path_planning.sub_sweep.SweepSearcher.find_safe_turning_grid" href="#path_planning.sub_sweep.SweepSearcher.find_safe_turning_grid">find_safe_turning_grid</a></code></li>
<li><code><a title="path_planning.sub_sweep.SweepSearcher.is_search_done" href="#path_planning.sub_sweep.SweepSearcher.is_search_done">is_search_done</a></code></li>
<li><code><a title="path_planning.sub_sweep.SweepSearcher.move_target_grid" href="#path_planning.sub_sweep.SweepSearcher.move_target_grid">move_target_grid</a></code></li>
<li><code><a title="path_planning.sub_sweep.SweepSearcher.search_start_grid" href="#path_planning.sub_sweep.SweepSearcher.search_start_grid">search_start_grid</a></code></li>
<li><code><a title="path_planning.sub_sweep.SweepSearcher.swap_moving_direction" href="#path_planning.sub_sweep.SweepSearcher.swap_moving_direction">swap_moving_direction</a></code></li>
<li><code><a title="path_planning.sub_sweep.SweepSearcher.update_turning_window" href="#path_planning.sub_sweep.SweepSearcher.update_turning_window">update_turning_window</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>