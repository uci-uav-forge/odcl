<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>path_planning.grid_map_lib API documentation</title>
<meta name="description" content="Grid based sweep planner â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>path_planning.grid_map_lib</code></h1>
</header>
<section id="section-intro">
<p>Grid based sweep planner</p>
<p>original author: Atsushi Sakai
modifications made by: Rick Meade</p>
<p>This code is used and modified under MIT license.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Grid based sweep planner

original author: Atsushi Sakai
modifications made by: Rick Meade

This code is used and modified under MIT license.
&#34;&#34;&#34;

import matplotlib.pyplot as plt
import numpy as np


class GridMap:
    &#34;&#34;&#34;
    GridMap class
    &#34;&#34;&#34;

    def __init__(self, width, height, resolution, center_x, center_y, init_val=0.0):
        &#34;&#34;&#34;__init__

        :param width: number of grid for width
        :param height: number of grid for heigt
        :param resolution: grid resolution [m]
        :param center_x: center x position  [m]
        :param center_y: center y position [m]
        :param init_val: initial value for all grid
        &#34;&#34;&#34;
        self.width = width
        self.height = height
        self.resolution = resolution
        self.center_x = center_x
        self.center_y = center_y

        self.left_lower_x = self.center_x - self.width / 2.0 * self.resolution
        self.left_lower_y = self.center_y - self.height / 2.0 * self.resolution

        self.ndata = self.width * self.height
        self.data = [init_val] * self.ndata

    def get_value_from_xy_index(self, x_ind, y_ind):
        &#34;&#34;&#34;get_value_from_xy_index

        when the index is out of grid map area, return None

        :param x_ind: x index
        :param y_ind: y index
        &#34;&#34;&#34;

        grid_ind = self.calc_grid_index_from_xy_index(x_ind, y_ind)

        if 0 &lt;= grid_ind &lt; self.ndata:
            return self.data[grid_ind]
        else:
            return None

    def get_xy_index_from_xy_pos(self, x_pos, y_pos):
        &#34;&#34;&#34;get_xy_index_from_xy_pos

        :param x_pos: x position [m]
        :param y_pos: y position [m]
        &#34;&#34;&#34;
        x_ind = self.calc_xy_index_from_position(
            x_pos, self.left_lower_x, self.width)
        y_ind = self.calc_xy_index_from_position(
            y_pos, self.left_lower_y, self.height)

        return x_ind, y_ind

    def set_value_from_xy_pos(self, x_pos, y_pos, val):
        &#34;&#34;&#34;set_value_from_xy_pos

        return bool flag, which means setting value is succeeded or not

        :param x_pos: x position [m]
        :param y_pos: y position [m]
        :param val: grid value
        &#34;&#34;&#34;

        x_ind, y_ind = self.get_xy_index_from_xy_pos(x_pos, y_pos)

        if (not x_ind) or (not y_ind):
            return False  # NG

        flag = self.set_value_from_xy_index(x_ind, y_ind, val)

        return flag

    def set_value_from_xy_index(self, x_ind, y_ind, val):
        &#34;&#34;&#34;set_value_from_xy_index

        return bool flag, which means setting value is succeeded or not

        :param x_ind: x index
        :param y_ind: y index
        :param val: grid value
        &#34;&#34;&#34;

        if (x_ind is None) or (y_ind is None):
            return False, False

        grid_ind = int(y_ind * self.width + x_ind)

        if 0 &lt;= grid_ind &lt; self.ndata:
            self.data[grid_ind] = val
            return True  # OK
        else:
            return False  # NG

    def set_value_from_polygon(self, pol_x, pol_y, val, inside=True):
        &#34;&#34;&#34;set_value_from_polygon

        Setting value inside or outside polygon

        :param pol_x: x position list for a polygon
        :param pol_y: y position list for a polygon
        :param val: grid value
        :param inside: setting data inside or outside
        &#34;&#34;&#34;

        # making ring polygon
        if (pol_x[0] != pol_x[-1]) or (pol_y[0] != pol_y[-1]):
            pol_x.append(pol_x[0])
            pol_y.append(pol_y[0])

        # setting value for all grid
        for x_ind in range(self.width):
            for y_ind in range(self.height):
                x_pos, y_pos = self.calc_grid_central_xy_position_from_xy_index(
                    x_ind, y_ind)

                flag = self.check_inside_polygon(x_pos, y_pos, pol_x, pol_y)

                if flag is inside:
                    self.set_value_from_xy_index(x_ind, y_ind, val)

    def calc_grid_index_from_xy_index(self, x_ind, y_ind):
        grid_ind = int(y_ind * self.width + x_ind)
        return grid_ind

    def calc_grid_central_xy_position_from_xy_index(self, x_ind, y_ind):
        x_pos = self.calc_grid_central_xy_position_from_index(
            x_ind, self.left_lower_x)
        y_pos = self.calc_grid_central_xy_position_from_index(
            y_ind, self.left_lower_y)

        return x_pos, y_pos

    def calc_grid_central_xy_position_from_index(self, index, lower_pos):
        return lower_pos + index * self.resolution + self.resolution / 2.0

    def calc_xy_index_from_position(self, pos, lower_pos, max_index):
        ind = int(np.floor((pos - lower_pos) / self.resolution))
        if 0 &lt;= ind &lt;= max_index:
            return ind
        else:
            return None

    def check_occupied_from_xy_index(self, xind, yind, occupied_val=1.0):

        val = self.get_value_from_xy_index(xind, yind)

        if val is None or val &gt;= occupied_val:
            return True
        else:
            return False

    def expand_grid(self):
        xinds, yinds = [], []

        for ix in range(self.width):
            for iy in range(self.height):
                if self.check_occupied_from_xy_index(ix, iy):
                    xinds.append(ix)
                    yinds.append(iy)

        for (ix, iy) in zip(xinds, yinds):
            self.set_value_from_xy_index(ix + 1, iy, val=1.0)
            self.set_value_from_xy_index(ix, iy + 1, val=1.0)
            self.set_value_from_xy_index(ix + 1, iy + 1, val=1.0)
            self.set_value_from_xy_index(ix - 1, iy, val=1.0)
            self.set_value_from_xy_index(ix, iy - 1, val=1.0)
            self.set_value_from_xy_index(ix - 1, iy - 1, val=1.0)

    @staticmethod
    def check_inside_polygon(iox, ioy, x, y):

        npoint = len(x) - 1
        inside = False
        for i1 in range(npoint):
            i2 = (i1 + 1) % (npoint + 1)

            if x[i1] &gt;= x[i2]:
                min_x, max_x = x[i2], x[i1]
            else:
                min_x, max_x = x[i1], x[i2]
            if not min_x &lt; iox &lt; max_x:
                continue

            tmp1 = (y[i2] - y[i1]) / (x[i2] - x[i1])
            if (y[i1] + tmp1 * (iox - x[i1]) - ioy) &gt; 0.0:
                inside = not inside

        return inside

    def print_grid_map_info(self):
        print(&#34;width:&#34;, self.width)
        print(&#34;height:&#34;, self.height)
        print(&#34;resolution:&#34;, self.resolution)
        print(&#34;center_x:&#34;, self.center_x)
        print(&#34;center_y:&#34;, self.center_y)
        print(&#34;left_lower_x:&#34;, self.left_lower_x)
        print(&#34;left_lower_y:&#34;, self.left_lower_y)
        print(&#34;ndata:&#34;, self.ndata)

    def plot_grid_map(self, ax=None):

        grid_data = np.reshape(np.array(self.data), (self.height, self.width))
        if not ax:
            fig, ax = plt.subplots()
        heat_map = ax.pcolor(grid_data, cmap=&#34;Blues&#34;, vmin=0.0, vmax=1.0)
        plt.axis(&#34;equal&#34;)
        # plt.show()

        return heat_map


def test_polygon_set():
    ox = [0.0, 20.0, 50.0, 100.0, 130.0, 40.0]
    oy = [0.0, -20.0, 0.0, 30.0, 60.0, 80.0]

    grid_map = GridMap(600, 290, 0.7, 60.0, 30.5)

    grid_map.set_value_from_polygon(ox, oy, 1.0, inside=False)

    grid_map.plot_grid_map()

    plt.axis(&#34;equal&#34;)
    plt.grid(True)


def test_position_set():
    grid_map = GridMap(100, 120, 0.5, 10.0, -0.5)

    grid_map.set_value_from_xy_pos(10.1, -1.1, 1.0)
    grid_map.set_value_from_xy_pos(10.1, -0.1, 1.0)
    grid_map.set_value_from_xy_pos(10.1, 1.1, 1.0)
    grid_map.set_value_from_xy_pos(11.1, 0.1, 1.0)
    grid_map.set_value_from_xy_pos(10.1, 0.1, 1.0)
    grid_map.set_value_from_xy_pos(9.1, 0.1, 1.0)

    grid_map.plot_grid_map()


def main():
    print(&#34;start!!&#34;)

    test_position_set()
    test_polygon_set()

    plt.show()

    print(&#34;done!!&#34;)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="path_planning.grid_map_lib.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    print(&#34;start!!&#34;)

    test_position_set()
    test_polygon_set()

    plt.show()

    print(&#34;done!!&#34;)</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.test_polygon_set"><code class="name flex">
<span>def <span class="ident">test_polygon_set</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_polygon_set():
    ox = [0.0, 20.0, 50.0, 100.0, 130.0, 40.0]
    oy = [0.0, -20.0, 0.0, 30.0, 60.0, 80.0]

    grid_map = GridMap(600, 290, 0.7, 60.0, 30.5)

    grid_map.set_value_from_polygon(ox, oy, 1.0, inside=False)

    grid_map.plot_grid_map()

    plt.axis(&#34;equal&#34;)
    plt.grid(True)</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.test_position_set"><code class="name flex">
<span>def <span class="ident">test_position_set</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_position_set():
    grid_map = GridMap(100, 120, 0.5, 10.0, -0.5)

    grid_map.set_value_from_xy_pos(10.1, -1.1, 1.0)
    grid_map.set_value_from_xy_pos(10.1, -0.1, 1.0)
    grid_map.set_value_from_xy_pos(10.1, 1.1, 1.0)
    grid_map.set_value_from_xy_pos(11.1, 0.1, 1.0)
    grid_map.set_value_from_xy_pos(10.1, 0.1, 1.0)
    grid_map.set_value_from_xy_pos(9.1, 0.1, 1.0)

    grid_map.plot_grid_map()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="path_planning.grid_map_lib.GridMap"><code class="flex name class">
<span>class <span class="ident">GridMap</span></span>
<span>(</span><span>width, height, resolution, center_x, center_y, init_val=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>GridMap class</p>
<p><strong>init</strong></p>
<p>:param width: number of grid for width
:param height: number of grid for heigt
:param resolution: grid resolution [m]
:param center_x: center x position
[m]
:param center_y: center y position [m]
:param init_val: initial value for all grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GridMap:
    &#34;&#34;&#34;
    GridMap class
    &#34;&#34;&#34;

    def __init__(self, width, height, resolution, center_x, center_y, init_val=0.0):
        &#34;&#34;&#34;__init__

        :param width: number of grid for width
        :param height: number of grid for heigt
        :param resolution: grid resolution [m]
        :param center_x: center x position  [m]
        :param center_y: center y position [m]
        :param init_val: initial value for all grid
        &#34;&#34;&#34;
        self.width = width
        self.height = height
        self.resolution = resolution
        self.center_x = center_x
        self.center_y = center_y

        self.left_lower_x = self.center_x - self.width / 2.0 * self.resolution
        self.left_lower_y = self.center_y - self.height / 2.0 * self.resolution

        self.ndata = self.width * self.height
        self.data = [init_val] * self.ndata

    def get_value_from_xy_index(self, x_ind, y_ind):
        &#34;&#34;&#34;get_value_from_xy_index

        when the index is out of grid map area, return None

        :param x_ind: x index
        :param y_ind: y index
        &#34;&#34;&#34;

        grid_ind = self.calc_grid_index_from_xy_index(x_ind, y_ind)

        if 0 &lt;= grid_ind &lt; self.ndata:
            return self.data[grid_ind]
        else:
            return None

    def get_xy_index_from_xy_pos(self, x_pos, y_pos):
        &#34;&#34;&#34;get_xy_index_from_xy_pos

        :param x_pos: x position [m]
        :param y_pos: y position [m]
        &#34;&#34;&#34;
        x_ind = self.calc_xy_index_from_position(
            x_pos, self.left_lower_x, self.width)
        y_ind = self.calc_xy_index_from_position(
            y_pos, self.left_lower_y, self.height)

        return x_ind, y_ind

    def set_value_from_xy_pos(self, x_pos, y_pos, val):
        &#34;&#34;&#34;set_value_from_xy_pos

        return bool flag, which means setting value is succeeded or not

        :param x_pos: x position [m]
        :param y_pos: y position [m]
        :param val: grid value
        &#34;&#34;&#34;

        x_ind, y_ind = self.get_xy_index_from_xy_pos(x_pos, y_pos)

        if (not x_ind) or (not y_ind):
            return False  # NG

        flag = self.set_value_from_xy_index(x_ind, y_ind, val)

        return flag

    def set_value_from_xy_index(self, x_ind, y_ind, val):
        &#34;&#34;&#34;set_value_from_xy_index

        return bool flag, which means setting value is succeeded or not

        :param x_ind: x index
        :param y_ind: y index
        :param val: grid value
        &#34;&#34;&#34;

        if (x_ind is None) or (y_ind is None):
            return False, False

        grid_ind = int(y_ind * self.width + x_ind)

        if 0 &lt;= grid_ind &lt; self.ndata:
            self.data[grid_ind] = val
            return True  # OK
        else:
            return False  # NG

    def set_value_from_polygon(self, pol_x, pol_y, val, inside=True):
        &#34;&#34;&#34;set_value_from_polygon

        Setting value inside or outside polygon

        :param pol_x: x position list for a polygon
        :param pol_y: y position list for a polygon
        :param val: grid value
        :param inside: setting data inside or outside
        &#34;&#34;&#34;

        # making ring polygon
        if (pol_x[0] != pol_x[-1]) or (pol_y[0] != pol_y[-1]):
            pol_x.append(pol_x[0])
            pol_y.append(pol_y[0])

        # setting value for all grid
        for x_ind in range(self.width):
            for y_ind in range(self.height):
                x_pos, y_pos = self.calc_grid_central_xy_position_from_xy_index(
                    x_ind, y_ind)

                flag = self.check_inside_polygon(x_pos, y_pos, pol_x, pol_y)

                if flag is inside:
                    self.set_value_from_xy_index(x_ind, y_ind, val)

    def calc_grid_index_from_xy_index(self, x_ind, y_ind):
        grid_ind = int(y_ind * self.width + x_ind)
        return grid_ind

    def calc_grid_central_xy_position_from_xy_index(self, x_ind, y_ind):
        x_pos = self.calc_grid_central_xy_position_from_index(
            x_ind, self.left_lower_x)
        y_pos = self.calc_grid_central_xy_position_from_index(
            y_ind, self.left_lower_y)

        return x_pos, y_pos

    def calc_grid_central_xy_position_from_index(self, index, lower_pos):
        return lower_pos + index * self.resolution + self.resolution / 2.0

    def calc_xy_index_from_position(self, pos, lower_pos, max_index):
        ind = int(np.floor((pos - lower_pos) / self.resolution))
        if 0 &lt;= ind &lt;= max_index:
            return ind
        else:
            return None

    def check_occupied_from_xy_index(self, xind, yind, occupied_val=1.0):

        val = self.get_value_from_xy_index(xind, yind)

        if val is None or val &gt;= occupied_val:
            return True
        else:
            return False

    def expand_grid(self):
        xinds, yinds = [], []

        for ix in range(self.width):
            for iy in range(self.height):
                if self.check_occupied_from_xy_index(ix, iy):
                    xinds.append(ix)
                    yinds.append(iy)

        for (ix, iy) in zip(xinds, yinds):
            self.set_value_from_xy_index(ix + 1, iy, val=1.0)
            self.set_value_from_xy_index(ix, iy + 1, val=1.0)
            self.set_value_from_xy_index(ix + 1, iy + 1, val=1.0)
            self.set_value_from_xy_index(ix - 1, iy, val=1.0)
            self.set_value_from_xy_index(ix, iy - 1, val=1.0)
            self.set_value_from_xy_index(ix - 1, iy - 1, val=1.0)

    @staticmethod
    def check_inside_polygon(iox, ioy, x, y):

        npoint = len(x) - 1
        inside = False
        for i1 in range(npoint):
            i2 = (i1 + 1) % (npoint + 1)

            if x[i1] &gt;= x[i2]:
                min_x, max_x = x[i2], x[i1]
            else:
                min_x, max_x = x[i1], x[i2]
            if not min_x &lt; iox &lt; max_x:
                continue

            tmp1 = (y[i2] - y[i1]) / (x[i2] - x[i1])
            if (y[i1] + tmp1 * (iox - x[i1]) - ioy) &gt; 0.0:
                inside = not inside

        return inside

    def print_grid_map_info(self):
        print(&#34;width:&#34;, self.width)
        print(&#34;height:&#34;, self.height)
        print(&#34;resolution:&#34;, self.resolution)
        print(&#34;center_x:&#34;, self.center_x)
        print(&#34;center_y:&#34;, self.center_y)
        print(&#34;left_lower_x:&#34;, self.left_lower_x)
        print(&#34;left_lower_y:&#34;, self.left_lower_y)
        print(&#34;ndata:&#34;, self.ndata)

    def plot_grid_map(self, ax=None):

        grid_data = np.reshape(np.array(self.data), (self.height, self.width))
        if not ax:
            fig, ax = plt.subplots()
        heat_map = ax.pcolor(grid_data, cmap=&#34;Blues&#34;, vmin=0.0, vmax=1.0)
        plt.axis(&#34;equal&#34;)
        # plt.show()

        return heat_map</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="path_planning.grid_map_lib.GridMap.check_inside_polygon"><code class="name flex">
<span>def <span class="ident">check_inside_polygon</span></span>(<span>iox, ioy, x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def check_inside_polygon(iox, ioy, x, y):

    npoint = len(x) - 1
    inside = False
    for i1 in range(npoint):
        i2 = (i1 + 1) % (npoint + 1)

        if x[i1] &gt;= x[i2]:
            min_x, max_x = x[i2], x[i1]
        else:
            min_x, max_x = x[i1], x[i2]
        if not min_x &lt; iox &lt; max_x:
            continue

        tmp1 = (y[i2] - y[i1]) / (x[i2] - x[i1])
        if (y[i1] + tmp1 * (iox - x[i1]) - ioy) &gt; 0.0:
            inside = not inside

    return inside</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="path_planning.grid_map_lib.GridMap.calc_grid_central_xy_position_from_index"><code class="name flex">
<span>def <span class="ident">calc_grid_central_xy_position_from_index</span></span>(<span>self, index, lower_pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_grid_central_xy_position_from_index(self, index, lower_pos):
    return lower_pos + index * self.resolution + self.resolution / 2.0</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.calc_grid_central_xy_position_from_xy_index"><code class="name flex">
<span>def <span class="ident">calc_grid_central_xy_position_from_xy_index</span></span>(<span>self, x_ind, y_ind)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_grid_central_xy_position_from_xy_index(self, x_ind, y_ind):
    x_pos = self.calc_grid_central_xy_position_from_index(
        x_ind, self.left_lower_x)
    y_pos = self.calc_grid_central_xy_position_from_index(
        y_ind, self.left_lower_y)

    return x_pos, y_pos</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.calc_grid_index_from_xy_index"><code class="name flex">
<span>def <span class="ident">calc_grid_index_from_xy_index</span></span>(<span>self, x_ind, y_ind)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_grid_index_from_xy_index(self, x_ind, y_ind):
    grid_ind = int(y_ind * self.width + x_ind)
    return grid_ind</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.calc_xy_index_from_position"><code class="name flex">
<span>def <span class="ident">calc_xy_index_from_position</span></span>(<span>self, pos, lower_pos, max_index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_xy_index_from_position(self, pos, lower_pos, max_index):
    ind = int(np.floor((pos - lower_pos) / self.resolution))
    if 0 &lt;= ind &lt;= max_index:
        return ind
    else:
        return None</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.check_occupied_from_xy_index"><code class="name flex">
<span>def <span class="ident">check_occupied_from_xy_index</span></span>(<span>self, xind, yind, occupied_val=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_occupied_from_xy_index(self, xind, yind, occupied_val=1.0):

    val = self.get_value_from_xy_index(xind, yind)

    if val is None or val &gt;= occupied_val:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.expand_grid"><code class="name flex">
<span>def <span class="ident">expand_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_grid(self):
    xinds, yinds = [], []

    for ix in range(self.width):
        for iy in range(self.height):
            if self.check_occupied_from_xy_index(ix, iy):
                xinds.append(ix)
                yinds.append(iy)

    for (ix, iy) in zip(xinds, yinds):
        self.set_value_from_xy_index(ix + 1, iy, val=1.0)
        self.set_value_from_xy_index(ix, iy + 1, val=1.0)
        self.set_value_from_xy_index(ix + 1, iy + 1, val=1.0)
        self.set_value_from_xy_index(ix - 1, iy, val=1.0)
        self.set_value_from_xy_index(ix, iy - 1, val=1.0)
        self.set_value_from_xy_index(ix - 1, iy - 1, val=1.0)</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.get_value_from_xy_index"><code class="name flex">
<span>def <span class="ident">get_value_from_xy_index</span></span>(<span>self, x_ind, y_ind)</span>
</code></dt>
<dd>
<div class="desc"><p>get_value_from_xy_index</p>
<p>when the index is out of grid map area, return None</p>
<p>:param x_ind: x index
:param y_ind: y index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_from_xy_index(self, x_ind, y_ind):
    &#34;&#34;&#34;get_value_from_xy_index

    when the index is out of grid map area, return None

    :param x_ind: x index
    :param y_ind: y index
    &#34;&#34;&#34;

    grid_ind = self.calc_grid_index_from_xy_index(x_ind, y_ind)

    if 0 &lt;= grid_ind &lt; self.ndata:
        return self.data[grid_ind]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.get_xy_index_from_xy_pos"><code class="name flex">
<span>def <span class="ident">get_xy_index_from_xy_pos</span></span>(<span>self, x_pos, y_pos)</span>
</code></dt>
<dd>
<div class="desc"><p>get_xy_index_from_xy_pos</p>
<p>:param x_pos: x position [m]
:param y_pos: y position [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xy_index_from_xy_pos(self, x_pos, y_pos):
    &#34;&#34;&#34;get_xy_index_from_xy_pos

    :param x_pos: x position [m]
    :param y_pos: y position [m]
    &#34;&#34;&#34;
    x_ind = self.calc_xy_index_from_position(
        x_pos, self.left_lower_x, self.width)
    y_ind = self.calc_xy_index_from_position(
        y_pos, self.left_lower_y, self.height)

    return x_ind, y_ind</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.plot_grid_map"><code class="name flex">
<span>def <span class="ident">plot_grid_map</span></span>(<span>self, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_grid_map(self, ax=None):

    grid_data = np.reshape(np.array(self.data), (self.height, self.width))
    if not ax:
        fig, ax = plt.subplots()
    heat_map = ax.pcolor(grid_data, cmap=&#34;Blues&#34;, vmin=0.0, vmax=1.0)
    plt.axis(&#34;equal&#34;)
    # plt.show()

    return heat_map</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.print_grid_map_info"><code class="name flex">
<span>def <span class="ident">print_grid_map_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_grid_map_info(self):
    print(&#34;width:&#34;, self.width)
    print(&#34;height:&#34;, self.height)
    print(&#34;resolution:&#34;, self.resolution)
    print(&#34;center_x:&#34;, self.center_x)
    print(&#34;center_y:&#34;, self.center_y)
    print(&#34;left_lower_x:&#34;, self.left_lower_x)
    print(&#34;left_lower_y:&#34;, self.left_lower_y)
    print(&#34;ndata:&#34;, self.ndata)</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.set_value_from_polygon"><code class="name flex">
<span>def <span class="ident">set_value_from_polygon</span></span>(<span>self, pol_x, pol_y, val, inside=True)</span>
</code></dt>
<dd>
<div class="desc"><p>set_value_from_polygon</p>
<p>Setting value inside or outside polygon</p>
<p>:param pol_x: x position list for a polygon
:param pol_y: y position list for a polygon
:param val: grid value
:param inside: setting data inside or outside</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value_from_polygon(self, pol_x, pol_y, val, inside=True):
    &#34;&#34;&#34;set_value_from_polygon

    Setting value inside or outside polygon

    :param pol_x: x position list for a polygon
    :param pol_y: y position list for a polygon
    :param val: grid value
    :param inside: setting data inside or outside
    &#34;&#34;&#34;

    # making ring polygon
    if (pol_x[0] != pol_x[-1]) or (pol_y[0] != pol_y[-1]):
        pol_x.append(pol_x[0])
        pol_y.append(pol_y[0])

    # setting value for all grid
    for x_ind in range(self.width):
        for y_ind in range(self.height):
            x_pos, y_pos = self.calc_grid_central_xy_position_from_xy_index(
                x_ind, y_ind)

            flag = self.check_inside_polygon(x_pos, y_pos, pol_x, pol_y)

            if flag is inside:
                self.set_value_from_xy_index(x_ind, y_ind, val)</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.set_value_from_xy_index"><code class="name flex">
<span>def <span class="ident">set_value_from_xy_index</span></span>(<span>self, x_ind, y_ind, val)</span>
</code></dt>
<dd>
<div class="desc"><p>set_value_from_xy_index</p>
<p>return bool flag, which means setting value is succeeded or not</p>
<p>:param x_ind: x index
:param y_ind: y index
:param val: grid value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value_from_xy_index(self, x_ind, y_ind, val):
    &#34;&#34;&#34;set_value_from_xy_index

    return bool flag, which means setting value is succeeded or not

    :param x_ind: x index
    :param y_ind: y index
    :param val: grid value
    &#34;&#34;&#34;

    if (x_ind is None) or (y_ind is None):
        return False, False

    grid_ind = int(y_ind * self.width + x_ind)

    if 0 &lt;= grid_ind &lt; self.ndata:
        self.data[grid_ind] = val
        return True  # OK
    else:
        return False  # NG</code></pre>
</details>
</dd>
<dt id="path_planning.grid_map_lib.GridMap.set_value_from_xy_pos"><code class="name flex">
<span>def <span class="ident">set_value_from_xy_pos</span></span>(<span>self, x_pos, y_pos, val)</span>
</code></dt>
<dd>
<div class="desc"><p>set_value_from_xy_pos</p>
<p>return bool flag, which means setting value is succeeded or not</p>
<p>:param x_pos: x position [m]
:param y_pos: y position [m]
:param val: grid value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value_from_xy_pos(self, x_pos, y_pos, val):
    &#34;&#34;&#34;set_value_from_xy_pos

    return bool flag, which means setting value is succeeded or not

    :param x_pos: x position [m]
    :param y_pos: y position [m]
    :param val: grid value
    &#34;&#34;&#34;

    x_ind, y_ind = self.get_xy_index_from_xy_pos(x_pos, y_pos)

    if (not x_ind) or (not y_ind):
        return False  # NG

    flag = self.set_value_from_xy_index(x_ind, y_ind, val)

    return flag</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="path_planning" href="index.html">path_planning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="path_planning.grid_map_lib.main" href="#path_planning.grid_map_lib.main">main</a></code></li>
<li><code><a title="path_planning.grid_map_lib.test_polygon_set" href="#path_planning.grid_map_lib.test_polygon_set">test_polygon_set</a></code></li>
<li><code><a title="path_planning.grid_map_lib.test_position_set" href="#path_planning.grid_map_lib.test_position_set">test_position_set</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="path_planning.grid_map_lib.GridMap" href="#path_planning.grid_map_lib.GridMap">GridMap</a></code></h4>
<ul class="">
<li><code><a title="path_planning.grid_map_lib.GridMap.calc_grid_central_xy_position_from_index" href="#path_planning.grid_map_lib.GridMap.calc_grid_central_xy_position_from_index">calc_grid_central_xy_position_from_index</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.calc_grid_central_xy_position_from_xy_index" href="#path_planning.grid_map_lib.GridMap.calc_grid_central_xy_position_from_xy_index">calc_grid_central_xy_position_from_xy_index</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.calc_grid_index_from_xy_index" href="#path_planning.grid_map_lib.GridMap.calc_grid_index_from_xy_index">calc_grid_index_from_xy_index</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.calc_xy_index_from_position" href="#path_planning.grid_map_lib.GridMap.calc_xy_index_from_position">calc_xy_index_from_position</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.check_inside_polygon" href="#path_planning.grid_map_lib.GridMap.check_inside_polygon">check_inside_polygon</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.check_occupied_from_xy_index" href="#path_planning.grid_map_lib.GridMap.check_occupied_from_xy_index">check_occupied_from_xy_index</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.expand_grid" href="#path_planning.grid_map_lib.GridMap.expand_grid">expand_grid</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.get_value_from_xy_index" href="#path_planning.grid_map_lib.GridMap.get_value_from_xy_index">get_value_from_xy_index</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.get_xy_index_from_xy_pos" href="#path_planning.grid_map_lib.GridMap.get_xy_index_from_xy_pos">get_xy_index_from_xy_pos</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.plot_grid_map" href="#path_planning.grid_map_lib.GridMap.plot_grid_map">plot_grid_map</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.print_grid_map_info" href="#path_planning.grid_map_lib.GridMap.print_grid_map_info">print_grid_map_info</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.set_value_from_polygon" href="#path_planning.grid_map_lib.GridMap.set_value_from_polygon">set_value_from_polygon</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.set_value_from_xy_index" href="#path_planning.grid_map_lib.GridMap.set_value_from_xy_index">set_value_from_xy_index</a></code></li>
<li><code><a title="path_planning.grid_map_lib.GridMap.set_value_from_xy_pos" href="#path_planning.grid_map_lib.GridMap.set_value_from_xy_pos">set_value_from_xy_pos</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>