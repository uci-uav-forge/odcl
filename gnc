# /usr/bin/python3

#######################
#### Interop Client ###
#######################

# This rosnode coordinates communication between nodes
# on the ROS network and the AUVSI interop server. It
# relies on the `uavf` python package.

import rospy, threading, pyproj, math, json, os, glob, sys
from pymavlink import mavutil
from mavros import mavlink
from geometry_msgs.msg import PoseStamped
from mavros_msgs.msg import (
    Mavlink,
    Altitude,
    ExtendedState,
    HomePosition,
    ParamValue,
    State,
    WaypointList,
    WaypointReached,
    Waypoint,
)
from mavros_msgs.srv import (
    CommandBool,
    ParamGet,
    ParamSet,
    SetMode,
    SetModeRequest,
    WaypointClear,
    WaypointPush,
)

from sensor_msgs.msg import NavSatFix, Imu


def get_last_log():
    try:
        log_path = os.environ["PX4_LOG_DIR"]
    except KeyError:
        try:
            log_path = os.path.join(os.environ["ROS_HOME"], "log")
        except KeyError:
            log_path = os.path.join(os.environ["HOME"], ".ros/log")
    last_log_dir = sorted(glob.glob(os.path.join(log_path, "*")))[-1]
    last_log = sorted(glob.glob(os.path.join(last_log_dir, "*.ulg")))[-1]
    return last_log


def read_mission(mission_filename):
    wps = []
    with open(mission_filename, "r") as f:
        for waypoint in read_plan_file(f):
            wps.append(waypoint)
            rospy.logdebug(waypoint)

    # set first item to current
    if wps:
        wps[0].is_current = True

    return wps


def read_plan_file(f):
    d = json.load(f)
    if "mission" in d:
        d = d["mission"]

    if "items" in d:
        for wp in d["items"]:
            yield Waypoint(
                is_current=False,
                frame=int(wp["frame"]),
                command=int(wp["command"]),
                param1=float("nan" if wp["params"][0] is None else wp["params"][0]),
                param2=float("nan" if wp["params"][1] is None else wp["params"][1]),
                param3=float("nan" if wp["params"][2] is None else wp["params"][2]),
                param4=float("nan" if wp["params"][3] is None else wp["params"][3]),
                x_lat=float(wp["params"][4]),
                y_long=float(wp["params"][5]),
                z_alt=float(wp["params"][6]),
                autocontinue=bool(wp["autoContinue"]),
            )
    else:
        raise IOError("no mission items")


class GNC(object):
    def __init__(self):
        self.altitude = Altitude()
        self.extended_state = ExtendedState()
        self.global_position = NavSatFix()
        self.imu_data = Imu()
        self.home_position = HomePosition()
        self.local_position = PoseStamped()
        self.mission_wp = WaypointList()
        self.state = State()
        self.mav_type = None

        self.sub_topics_ready = {
            key: False
            for key in [
                "alt",
                "ext_state",
                "global_pos",
                "home_pos",
                "local_pos",
                "mission_wp",
                "state",
                "imu",
            ]
        }

        # ROS services
        service_timeout = 30
        rospy.loginfo("waiting for ROS services")
        try:
            rospy.wait_for_service("mavros/param/get", service_timeout)
            rospy.wait_for_service("mavros/param/set", service_timeout)
            rospy.wait_for_service("mavros/cmd/arming", service_timeout)
            rospy.wait_for_service("mavros/mission/push", service_timeout)
            rospy.wait_for_service("mavros/mission/clear", service_timeout)
            rospy.wait_for_service("mavros/set_mode", service_timeout)
            rospy.loginfo("ROS services are up")
        except rospy.ROSException:
            raise rospy.ROSException("failed to connect to services")
        self.get_param_srv = rospy.ServiceProxy("mavros/param/get", ParamGet)
        self.set_param_srv = rospy.ServiceProxy("mavros/param/set", ParamSet)
        self.set_arming_srv = rospy.ServiceProxy("mavros/cmd/arming", CommandBool)
        self.set_mode_srv = rospy.ServiceProxy("mavros/set_mode", SetMode)
        self.wp_clear_srv = rospy.ServiceProxy("mavros/mission/clear", WaypointClear)
        self.wp_push_srv = rospy.ServiceProxy("mavros/mission/push", WaypointPush)

        # ROS subscribers
        self.alt_sub = rospy.Subscriber(
            "mavros/altitude", Altitude, self.altitude_callback
        )
        self.ext_state_sub = rospy.Subscriber(
            "mavros/extended_state", ExtendedState, self.extended_state_callback
        )
        self.global_pos_sub = rospy.Subscriber(
            "mavros/global_position/global", NavSatFix, self.global_position_callback
        )
        self.imu_data_sub = rospy.Subscriber(
            "mavros/imu/data", Imu, self.imu_data_callback
        )
        self.home_pos_sub = rospy.Subscriber(
            "mavros/home_position/home", HomePosition, self.home_position_callback
        )
        self.local_pos_sub = rospy.Subscriber(
            "mavros/local_position/pose", PoseStamped, self.local_position_callback
        )
        self.mission_wp_sub = rospy.Subscriber(
            "mavros/mission/waypoints", WaypointList, self.mission_wp_callback
        )
        self.state_sub = rospy.Subscriber("mavros/state", State, self.state_callback)

        self.mission_item_reached = -1  # first mission item is 0
        self.mission_name = ""

        self.mavlink_pub = rospy.Publisher("mavlink/to", Mavlink, queue_size=1)
        self.mission_item_reached_sub = rospy.Subscriber(
            "mavros/mission/reached",
            WaypointReached,
            self.mission_item_reached_callback,
        )

        # need to simulate heartbeat to prevent datalink loss detection
        self.hb_mav_msg = mavutil.mavlink.MAVLink_heartbeat_message(
            mavutil.mavlink.MAV_TYPE_GCS, 0, 0, 0, 0, 0
        )
        self.hb_mav_msg.pack(mavutil.mavlink.MAVLink("", 2, 1))
        self.hb_ros_msg = mavlink.convert_to_rosmsg(self.hb_mav_msg)
        self.hb_thread = threading.Thread(target=self.send_heartbeat, args=())
        self.hb_thread.daemon = True
        self.hb_thread.start()

    def tearDown(self):
        self.log_topic_vars()

    #
    # Callback functions
    #
    def altitude_callback(self, data):
        self.altitude = data

        # amsl has been observed to be nan while other fields are valid
        if not self.sub_topics_ready["alt"] and not math.isnan(data.amsl):
            self.sub_topics_ready["alt"] = True

    def extended_state_callback(self, data):
        if self.extended_state.vtol_state != data.vtol_state:
            rospy.loginfo(
                "VTOL state changed from {0} to {1}".format(
                    mavutil.mavlink.enums["MAV_VTOL_STATE"][
                        self.extended_state.vtol_state
                    ].name,
                    mavutil.mavlink.enums["MAV_VTOL_STATE"][data.vtol_state].name,
                )
            )

        if self.extended_state.landed_state != data.landed_state:
            rospy.loginfo(
                "landed state changed from {0} to {1}".format(
                    mavutil.mavlink.enums["MAV_LANDED_STATE"][
                        self.extended_state.landed_state
                    ].name,
                    mavutil.mavlink.enums["MAV_LANDED_STATE"][data.landed_state].name,
                )
            )

        self.extended_state = data

        if not self.sub_topics_ready["ext_state"]:
            self.sub_topics_ready["ext_state"] = True

    def global_position_callback(self, data):
        self.global_position = data

        if not self.sub_topics_ready["global_pos"]:
            self.sub_topics_ready["global_pos"] = True

    def imu_data_callback(self, data):
        self.imu_data = data

        if not self.sub_topics_ready["imu"]:
            self.sub_topics_ready["imu"] = True

    def home_position_callback(self, data):
        self.home_position = data

        if not self.sub_topics_ready["home_pos"]:
            self.sub_topics_ready["home_pos"] = True

    def local_position_callback(self, data):
        self.local_position = data

        if not self.sub_topics_ready["local_pos"]:
            self.sub_topics_ready["local_pos"] = True

    def mission_wp_callback(self, data):
        if self.mission_wp.current_seq != data.current_seq:
            rospy.loginfo(
                "current mission waypoint sequence updated: {0}".format(
                    data.current_seq
                )
            )

        self.mission_wp = data

        if not self.sub_topics_ready["mission_wp"]:
            self.sub_topics_ready["mission_wp"] = True

    def state_callback(self, data):
        if self.state.armed != data.armed:
            rospy.loginfo(
                "armed state changed from {0} to {1}".format(
                    self.state.armed, data.armed
                )
            )

        if self.state.connected != data.connected:
            rospy.loginfo(
                "connected changed from {0} to {1}".format(
                    self.state.connected, data.connected
                )
            )

        if self.state.mode != data.mode:
            rospy.loginfo(
                "mode changed from {0} to {1}".format(self.state.mode, data.mode)
            )

        if self.state.system_status != data.system_status:
            rospy.loginfo(
                "system_status changed from {0} to {1}".format(
                    mavutil.mavlink.enums["MAV_STATE"][self.state.system_status].name,
                    mavutil.mavlink.enums["MAV_STATE"][data.system_status].name,
                )
            )

        self.state = data

        # mavros publishes a disconnected state message on init
        if not self.sub_topics_ready["state"] and data.connected:
            self.sub_topics_ready["state"] = True

    #
    # Helper methods
    #
    def set_arm(self, arm, timeout):
        """arm: True to arm or False to disarm, timeout(int): seconds"""
        rospy.loginfo("setting FCU arm: {0}".format(arm))
        old_arm = self.state.armed
        loop_freq = 1  # Hz
        rate = rospy.Rate(loop_freq)
        arm_set = False
        for i in range(timeout * loop_freq):
            if self.state.armed == arm:
                arm_set = True
                rospy.loginfo(
                    f"Fet arm success | seconds: {i / loop_freq} of {timeout}"
                )
                break
            else:
                try:
                    res = self.set_arming_srv(arm)
                    if not res.success:
                        rospy.logerr("Failed to send arm command")
                except rospy.ServiceException as e:
                    rospy.logerr(e)

            rate.sleep()

        if not arm_set:
            rospy.logerr(
                f"Failed to set arm | new arm: {arm}, old arm: {old_arm} | timeout(seconds): {timeout}"
            )

    def set_mode(self, mode, timeout):
        """mode: PX4 mode string, timeout(int): seconds"""
        rospy.loginfo("setting FCU mode: {0}".format(mode))
        old_mode = self.state.mode
        loop_freq = 1  # Hz
        rate = rospy.Rate(loop_freq)
        mode_set = False
        for i in range(timeout * loop_freq):
            if self.state.mode == mode:
                mode_set = True
                rospy.loginfo(
                    "set mode success | seconds: {0} of {1}".format(
                        i / loop_freq, timeout
                    )
                )
                break
            else:
                try:
                    res = self.set_mode_srv(0, mode)  # 0 is custom mode
                    if not res.mode_sent:
                        rospy.logerr("failed to send mode command")
                except rospy.ServiceException as e:
                    rospy.logerr(e)

            rate.sleep()

        if not mode_set:
            rospy.logerr(
                f"Failed to set mode | new mode: {mode}, old mode: {old_mode} | timeout(seconds): {timeout}"
            )

    def set_param(self, param_id, param_value, timeout):
        """param: PX4 param string, ParamValue, timeout(int): seconds"""
        if param_value.integer != 0:
            value = param_value.integer
        else:
            value = param_value.real
        rospy.loginfo(f"Setting PX4 parameter: {param_id} with value {value}")
        loop_freq = 1  # Hz
        rate = rospy.Rate(loop_freq)
        param_set = False
        for i in range(timeout * loop_freq):
            try:
                res = self.set_param_srv(param_id, param_value)
                if res.success:
                    rospy.loginfo(
                        "param {0} set to {1} | seconds: {2} of {3}".format(
                            param_id, value, i / loop_freq, timeout
                        )
                    )
                break
            except rospy.ServiceException as e:
                rospy.logerr(e)

            rate.sleep()

        if not res.success:
            rospy.logerr(
                f"Failed to set param | param_id: {param_id}, param_value: {value} | timeout(seconds): {timeout}"
            )

    def wait_for_topics(self, timeout):
        """wait for simulation to be ready, make sure we're getting topic info
        from all topics by checking dictionary of flag values set in callbacks,
        timeout(int): seconds"""
        rospy.loginfo("waiting for subscribed topics to be ready")
        loop_freq = 1  # Hz
        rate = rospy.Rate(loop_freq)
        simulation_ready = False
        for iter, i in enumerate(range(timeout * loop_freq)):
            rospy.loginfo(f"Waiting for data... {iter}")
            if all([value for value in self.sub_topics_ready.values()]):
                simulation_ready = True
                rospy.loginfo(
                    "simulation topics ready | seconds: {0} of {1}".format(
                        i / loop_freq, timeout
                    )
                )
                break
            rate.sleep()

        if not simulation_ready:
            rospy.logerr(
                f"Failed to hear from all subscribed simulation topics | topic ready flags: {self.sub_topics_ready} | timeout(seconds): {timeout}"
            )
        else:
            rospy.loginfo(f"Simulation topics ready!")

    def wait_for_landed_state(self, desired_landed_state, timeout, index):
        rospy.loginfo(
            "waiting for landed state | state: {0}, index: {1}".format(
                mavutil.mavlink.enums["MAV_LANDED_STATE"][desired_landed_state].name,
                index,
            )
        )
        loop_freq = 10  # Hz
        rate = rospy.Rate(loop_freq)
        landed_state_confirmed = False
        for i in range(timeout * loop_freq):
            if self.extended_state.landed_state == desired_landed_state:
                landed_state_confirmed = True
                rospy.loginfo(
                    "landed state confirmed | seconds: {0} of {1}".format(
                        i / loop_freq, timeout
                    )
                )
                break

            rate.sleep()

        if not landed_state_confirmed:
            rospy.logerr(
                f"Landed state not detected | desired: {0}, current: {1} | index: {2}, timeout(seconds): {3}".format(
                    mavutil.mavlink.enums["MAV_LANDED_STATE"][
                        desired_landed_state
                    ].name,
                    mavutil.mavlink.enums["MAV_LANDED_STATE"][
                        self.extended_state.landed_state
                    ].name,
                    index,
                    timeout,
                )
            )

    def wait_for_vtol_state(self, transition, timeout, index):
        """Wait for VTOL transition, timeout(int): seconds"""
        rospy.loginfo(
            "waiting for VTOL transition | transition: {0}, index: {1}".format(
                mavutil.mavlink.enums["MAV_VTOL_STATE"][transition].name, index
            )
        )
        loop_freq = 10  # Hz
        rate = rospy.Rate(loop_freq)
        transitioned = False
        for i in range(timeout * loop_freq):
            if transition == self.extended_state.vtol_state:
                rospy.loginfo(
                    "transitioned | seconds: {0} of {1}".format(i / loop_freq, timeout)
                )
                transitioned = True
                break

            rate.sleep()

        if not transitioned:
            rospy.logerr(
                f"Transition not detected | desired: {0}, current: {1} | index: {2} timeout(seconds): {3}".format(
                    mavutil.mavlink.enums["MAV_VTOL_STATE"][transition].name,
                    mavutil.mavlink.enums["MAV_VTOL_STATE"][
                        self.extended_state.vtol_state
                    ].name,
                    index,
                    timeout,
                )
            )

    def clear_wps(self, timeout):
        """timeout(int): seconds"""
        loop_freq = 1  # Hz
        rate = rospy.Rate(loop_freq)
        wps_cleared = False
        for i in range(timeout * loop_freq):
            if not self.mission_wp.waypoints:
                wps_cleared = True
                rospy.loginfo(
                    "clear waypoints success | seconds: {0} of {1}".format(
                        i / loop_freq, timeout
                    )
                )
                break
            else:
                try:
                    res = self.wp_clear_srv()
                    if not res.success:
                        rospy.logerr("failed to send waypoint clear command")
                except rospy.ServiceException as e:
                    rospy.logerr(e)

            rate.sleep()

        if not wps_cleared:
            rospy.logerr(
                f"failed to clear waypoints | timeout(seconds): {0}".format(timeout)
            )

    def send_wps(self, waypoints, timeout):
        """waypoints, timeout(int): seconds"""
        rospy.loginfo("sending mission waypoints")
        if self.mission_wp.waypoints:
            rospy.loginfo("FCU already has mission waypoints")

        loop_freq = 1  # Hz
        rate = rospy.Rate(loop_freq)
        wps_sent = False
        wps_verified = False
        for i in range(timeout * loop_freq):
            if not wps_sent:
                try:
                    res = self.wp_push_srv(start_index=0, waypoints=waypoints)
                    wps_sent = res.success
                    if wps_sent:
                        rospy.loginfo("waypoints successfully transferred")
                except rospy.ServiceException as e:
                    rospy.logerr(e)
            else:
                if len(waypoints) == len(self.mission_wp.waypoints):
                    rospy.loginfo(
                        "number of waypoints transferred: {0}".format(len(waypoints))
                    )
                    wps_verified = True

            if wps_sent and wps_verified:
                rospy.loginfo(
                    "send waypoints success | seconds: {0} of {1}".format(
                        i / loop_freq, timeout
                    )
                )
                break

            rate.sleep()

        if not (wps_sent and wps_verified):
            rospy.logerr(
                f"mission could not be transferred and verified | timeout(seconds): {timeout}"
            )

    def wait_for_mav_type(self, timeout):
        """Wait for MAV_TYPE parameter, timeout(int): seconds"""
        rospy.loginfo("waiting for MAV_TYPE")
        loop_freq = 1  # Hz
        rate = rospy.Rate(loop_freq)
        res = False
        for i in range(timeout * loop_freq):
            try:
                res = self.get_param_srv("MAV_TYPE")
                if res.success:
                    self.mav_type = res.value.integer
                    rospy.loginfo(
                        "MAV_TYPE received | type: {0} | seconds: {1} of {2}".format(
                            mavutil.mavlink.enums["MAV_TYPE"][self.mav_type].name,
                            i / loop_freq,
                            timeout,
                        )
                    )
                    break
            except rospy.ServiceException as e:
                rospy.logerr(e)

            rate.sleep()

        if not res.success:
            rospy.logerr(
                f"MAV_TYPE param get failed | timeout(seconds): {0}".format(timeout)
            )

    def log_topic_vars(self):
        rospy.loginfo(f"Altitude: \t{self.altitude}")
        rospy.loginfo(f"Extended State: \t{self.extended_state}")
        rospy.loginfo(f"Global Position: \t{self.global_position}")
        rospy.loginfo(f"Local Position: \t{self.local_position}")
        rospy.loginfo(f"Mission Waypoints: \t{self.mission_wp}")
        rospy.loginfo(f"Home Position: \t{self.home_position}")
        rospy.loginfo(f"State: \t{self.state}")

    def send_heartbeat(self):
        rate = rospy.Rate(2)  # Hz
        while not rospy.is_shutdown():
            self.mavlink_pub.publish(self.hb_ros_msg)
            try:  # prevent garbage in console output when thread is killed
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def mission_item_reached_callback(self, data):
        if self.mission_item_reached != data.wp_seq:
            rospy.loginfo("mission item reached: {0}".format(data.wp_seq))
            self.mission_item_reached = data.wp_seq

    def distance_to_wp(self, lat, lon, alt):
        """alt(amsl): meters"""
        # TODO: use pyproj for this method for better accuracy.
        R = 6371000  # metres
        rlat1 = math.radians(lat)
        rlat2 = math.radians(self.global_position.latitude)

        rlat_d = math.radians(self.global_position.latitude - lat)
        rlon_d = math.radians(self.global_position.longitude - lon)

        a = math.sin(rlat_d / 2) * math.sin(rlat_d / 2) + math.cos(rlat1) * math.cos(
            rlat2
        ) * math.sin(rlon_d / 2) * math.sin(rlon_d / 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

        d = R * c
        alt_d = abs(alt - self.altitude.amsl)

        rospy.logdebug("d: {0}, alt_d: {1}".format(d, alt_d))
        return d, alt_d

    def reach_position(self, lat, lon, alt, timeout, index):
        """alt(amsl): meters, timeout(int): seconds"""
        rospy.loginfo(
            "trying to reach waypoint | lat: {0:.9f}, lon: {1:.9f}, alt: {2:.2f}, index: {3}".format(
                lat, lon, alt, index
            )
        )
        best_pos_xy_d = None
        best_pos_z_d = None
        reached = False
        mission_length = len(self.mission_wp.waypoints)

        # does it reach the position in 'timeout' seconds?
        loop_freq = 2  # Hz
        rate = rospy.Rate(loop_freq)
        for i in range(timeout * loop_freq):
            pos_xy_d, pos_z_d = self.distance_to_wp(lat, lon, alt)

            # remember best distances
            if not best_pos_xy_d or best_pos_xy_d > pos_xy_d:
                best_pos_xy_d = pos_xy_d
            if not best_pos_z_d or best_pos_z_d > pos_z_d:
                best_pos_z_d = pos_z_d

            # FCU advanced to the next mission item, or finished mission
            reached = (
                # advanced to next wp
                (index < self.mission_wp.current_seq)
                # end of mission
                or (
                    index == (mission_length - 1) and self.mission_item_reached == index
                )
            )

            if reached:
                rospy.loginfo(
                    "position reached | pos_xy_d: {0:.2f}, pos_z_d: {1:.2f}, index: {2} | seconds: {3} of {4}".format(
                        pos_xy_d, pos_z_d, index, i / loop_freq, timeout
                    )
                )
                break
            elif i == 0 or ((i / loop_freq) % 10) == 0:
                # log distance first iteration and every 10 sec
                rospy.loginfo(
                    "current distance to waypoint | pos_xy_d: {0:.2f}, pos_z_d: {1:.2f}, index: {2}".format(
                        pos_xy_d, pos_z_d, index
                    )
                )

            rate.sleep()

        if not reached:
            rospy.logerr(
                f"position not reached | lat: {0:.9f}, lon: {1:.9f}, alt: {2:.2f}, current pos_xy_d: {3:.2f}, current pos_z_d: {4:.2f}, best pos_xy_d: {5:.2f}, best pos_z_d: {6:.2f}, index: {7} | timeout(seconds): {8}".format(
                    lat,
                    lon,
                    alt,
                    pos_xy_d,
                    pos_z_d,
                    best_pos_xy_d,
                    best_pos_z_d,
                    index,
                    timeout,
                ),
            )

    #
    # Test method
    #
    def run_mission(self):
        """Test mission"""
        if len(sys.argv) < 2:
            raise FileNotFoundError("usage: gnc mission_file")

        self.mission_name = sys.argv[1]
        mission_file = os.path.dirname(os.path.realpath(__file__)) + "/" + sys.argv[1]

        rospy.loginfo("reading mission {0}".format(mission_file))
        try:
            wps = read_mission(mission_file)
        except IOError as e:
            raise IOError("could not read mission file: {0}".format(e))

        # make sure the simulation is ready to start the mission
        self.wait_for_topics(60)
        self.wait_for_landed_state(mavutil.mavlink.MAV_LANDED_STATE_ON_GROUND, 10, -1)
        self.wait_for_mav_type(10)

        # push waypoints to FCU and start mission
        self.send_wps(wps, 30)
        self.log_topic_vars()
        self.set_mode("AUTO.MISSION", 5)
        self.set_arm(True, 5)

        rospy.loginfo("run mission {0}".format(self.mission_name))
        for index, waypoint in enumerate(wps):
            # only check position for waypoints where this makes sense
            if (
                waypoint.frame == Waypoint.FRAME_GLOBAL_REL_ALT
                or waypoint.frame == Waypoint.FRAME_GLOBAL
            ):
                alt = waypoint.z_alt
                if waypoint.frame == Waypoint.FRAME_GLOBAL_REL_ALT:
                    alt += self.altitude.amsl - self.altitude.relative

                self.reach_position(waypoint.x_lat, waypoint.y_long, alt, 60, index)

            # check if VTOL transition happens if applicable
            if (
                waypoint.command == mavutil.mavlink.MAV_CMD_NAV_VTOL_TAKEOFF
                or waypoint.command == mavutil.mavlink.MAV_CMD_NAV_VTOL_LAND
                or waypoint.command == mavutil.mavlink.MAV_CMD_DO_VTOL_TRANSITION
            ):
                transition = waypoint.param1  # used by MAV_CMD_DO_VTOL_TRANSITION
                if (
                    waypoint.command == mavutil.mavlink.MAV_CMD_NAV_VTOL_TAKEOFF
                ):  # VTOL takeoff implies transition to FW
                    transition = mavutil.mavlink.MAV_VTOL_STATE_FW
                if (
                    waypoint.command == mavutil.mavlink.MAV_CMD_NAV_VTOL_LAND
                ):  # VTOL land implies transition to MC
                    transition = mavutil.mavlink.MAV_VTOL_STATE_MC

                self.wait_for_vtol_state(transition, 60, index)

            # after reaching position, wait for landing detection if applicable
            if (
                waypoint.command == mavutil.mavlink.MAV_CMD_NAV_VTOL_LAND
                or waypoint.command == mavutil.mavlink.MAV_CMD_NAV_LAND
            ):
                self.wait_for_landed_state(
                    mavutil.mavlink.MAV_LANDED_STATE_ON_GROUND, 120, index
                )

        self.set_arm(False, 5)
        self.clear_wps(5)

        rospy.loginfo("mission done, calculating performance metrics")
        last_log = get_last_log()
        rospy.loginfo("log file {0}".format(last_log))


if __name__ == "__main__":
    rospy.init_node("gnc")
    gnc = GNC()
    gnc.run_mission()
    rospy.spin()
